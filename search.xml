<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>熵减行动</title>
      <link href="/2024/07/02/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E7%86%B5%E5%87%8F%E8%A1%8C%E5%8A%A8/"/>
      <url>/2024/07/02/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E7%86%B5%E5%87%8F%E8%A1%8C%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="起由"><a href="#起由" class="headerlink" title="起由"></a>起由</h1><p>经历了22年的巨变，我的职业生涯突然感觉到了很大的压力，今年（24年）尤其感觉到严重的压力，从去年年底得了一次甲流开始，过敏的不仅仅是我的呼吸道，大脑神经一直到现在也在过敏，持续了半年的时间，这段期间，精神内耗到了极点，做事不专注，每天很累，但是仍然收货很小。从而促使我拿起以前看的书《从内耗到心流：复杂时代下的熵减行动指南》，从新走上熵减道路。</p><h1 id="什么是精神内耗"><a href="#什么是精神内耗" class="headerlink" title="什么是精神内耗"></a>什么是精神内耗</h1><pre><code>● 完美主义和强迫倾向：对自己期待过高，总纠缠于细节，要么过度行动，要么迟迟不行动。● 总将焦点放在不可控的结果上：纠结于过去和未来，一直逃避现实，这是内卷群体的通病。● 高敏感、低自尊：过度在意他人言行，总觉得与自己有关，陷入猜疑却又不敢去当面确认。● 高压力、低欲望：找不到压力源，无法说清自己的感受，过度思虑，刻意压抑正常的需求。</code></pre><h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><h2 id="什么是熵增"><a href="#什么是熵增" class="headerlink" title="什么是熵增"></a>什么是熵增</h2><ul><li>这个世界在不停的加加加，各类东西层出不穷，各种思想的教导和社会的反向例子让人迷茫甚至混乱，我们每天被各种噪音包围，跟精神患者一样接受着这个世界的各种信息的刺激，</li><li>导致一个人，一会做这，一会干那，情绪时高时低，躺着无法安心入睡，站着无法注意力集中，总之，精神世界都极度散乱。躺平以及优越的生活环境也无法躲过这个散乱的空虚感，</li><li>最后成了”三十岁死了，八十岁掩埋的人“</li></ul><h2 id="人为什么要努力"><a href="#人为什么要努力" class="headerlink" title="人为什么要努力"></a>人为什么要努力</h2><p>   生命活动就是努力的过程，也是对抗熵增的过程，它是纯利己的，和社会期许及个人道德无关.<br>   万物都是开始从有序到无序，我们的生命都是抵制在生活中产生的正熵，让他在一个稳定的水平上。</p><h2 id="熵减逻辑"><a href="#熵减逻辑" class="headerlink" title="熵减逻辑"></a>熵减逻辑</h2><ul><li>认知熵减<br> 这个世界，总会变成无序或者封闭半死的状态，为了让一切变成高效，且我们每个人生活幸福感提高，那就让我们的生活有序，让思想有序，吸收有效的能量，对外开放，主动排除高熵的垃圾，让我们的生活和思想从回有序状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新开始</title>
      <link href="/2024/06/17/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/today_start/"/>
      <url>/2024/06/17/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/today_start/</url>
      
        <content type="html"><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><ul><li>现在遇到了瓶颈，什么东西都懂一些，但是是否能表达的前后连贯，让人看的饱满，仍需要多练习。</li></ul><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2><div class="markmap-container" style="height:undefined">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;大主题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;背景原因&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;发展经过&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;论证方法&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;作者观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;相似观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;总结范式&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;收集case&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;收集名句&quot;}]}"></svg></div><h2 id="观点评论"><a href="#观点评论" class="headerlink" title="观点评论"></a>观点评论</h2><ul><li>聚沙成塔 集腋成裘 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学冲浪</title>
      <link href="/2023/07/02/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E4%BA%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%82%A3%E4%BA%9B%E6%98%AF/"/>
      <url>/2023/07/02/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E4%BA%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%82%A3%E4%BA%9B%E6%98%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="万物互联"><a href="#万物互联" class="headerlink" title="万物互联"></a>万物互联</h1><p>当今社会，都地球村了，你要是看不到村头村尾的事，那只能说这个村的精彩，你不配拥有八卦互吹的场面</p><h1 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h1><p>vps专用： <a href="https://bandwagonhost.com/">这里可以买到服务</a><br>域名专用： 腾讯云和阿里云都可以买到域名。</p><h1 id="2、初步联通"><a href="#2、初步联通" class="headerlink" title="2、初步联通"></a>2、初步联通</h1><p>域名的映射 <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-154005@2x.png" alt="先把域名映射到vps的ip上"></p><h1 id="3、登录vps"><a href="#3、登录vps" class="headerlink" title="3、登录vps"></a>3、登录vps</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release &amp;&amp; yum install -y nginx</span><br></pre></td></tr></table></figure><h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><h2 id="安装certbot-获取证书"><a href="#安装certbot-获取证书" class="headerlink" title="安装certbot 获取证书"></a>安装certbot 获取证书</h2><p>先去官网：<a href="https://certbot.eff.org/instructions?ws=nginx&os=centosrhel8">这里跳转官网</a></p><p>点击如下：<img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-154620@2x.png" alt="入口图片"></p><p>如碰到安装snap的问题，请跳转如下链接<a href="https://stackoverflow.com/questions/74960690/try-to-install-snapd-but-giving-conflicting-requests-error">解决snap问题</a></p><details><summary>可参考的安装包和命令</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wget https://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/rpm-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">wget https://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/rpm-libs-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">wget https://dl.rockylinux.org/pub/rocky/8/BaseOS/aarch64/os/Packages/s/selinux-policy-3.14.3-108.el8.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/libsemanage-2.9-9.el8.x86_64.rpm --allowerasing -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/policycoreutils-2.9-19.el8.x86_64.rpm -y</span><br><span class="line"></span><br><span class="line">sudo rpm -i --force rpm-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">sudo rpm -i --force rpm-libs-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">sudo rpm -i --force selinux-policy-3.14.3-108.el8.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/python3-libsemanage-2.9-9.el8.x86_64.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/python3-policycoreutils-2.9-19.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/policycoreutils-python-utils-2.9-19.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/selinux-policy-minimum-3.14.3-108.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.2-1.el8.x86_64.rpm -y</span><br><span class="line"></span><br><span class="line">sudo yum install https://download-ib01.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/s/snapd-selinux-2.57.6-2.el8.noarch.rpm -y</span><br><span class="line"></span><br><span class="line">sudo yum install snapd -y</span><br><span class="line">sudo yum update snapd  -y</span><br></pre></td></tr></table></figure></details><h1 id="4、安装v2ray"><a href="#4、安装v2ray" class="headerlink" title="4、安装v2ray"></a>4、安装v2ray</h1><p>采用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p>采用如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;log&quot;:&#123;&quot;access&quot;:&quot;/var/log/v2ray/access.log&quot;,&quot;error&quot;:&quot;/var/log/v2ray/error.log&quot;,&quot;loglevel&quot;:&quot;warning&quot;&#125;,&quot;inbounds&quot;:[&#123;&quot;port&quot;:xxx,&quot;listen&quot;:&quot;127.0.0.1&quot;,&quot;protocol&quot;:&quot;vmess&quot;,&quot;settings&quot;:&#123;&quot;clients&quot;:[&#123;&quot;id&quot;:&quot;xxx&quot;,&quot;alterId&quot;:xxx&#125;]&#125;,&quot;streamSettings&quot;:&#123;&quot;network&quot;:&quot;ws&quot;,&quot;wsSettings&quot;:&#123;&quot;path&quot;:&quot;/xxx&quot;&#125;&#125;&#125;],&quot;outbounds&quot;:[&#123;&quot;protocol&quot;:&quot;freedom&quot;,&quot;settings&quot;:&#123;&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="5、配置nginx"><a href="#5、配置nginx" class="headerlink" title="5、配置nginx"></a>5、配置nginx</h1><p>检查nginx配置（一般为/etc/nginx/nginx.conf）<br>certbot自动化脚本会额外新增两个server：80和443，而原有的server 80的配置还在。<br>因此需要检查下，确保server只有两个，listen 80的是HTTP，listen 443的是HTTPS，多余的server配置注释掉。</p><p>最后如下图所示配置</p><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-164433@2x.png" alt="nginx配置"></p><h1 id="6、安装客户端"><a href="#6、安装客户端" class="headerlink" title="6、安装客户端"></a>6、安装客户端</h1><p>不同的系统，选择不同的客户端：<a href="https://www.linuxv2ray.com/client/">客户端安装</a></p><h1 id="7、客户端的配置"><a href="#7、客户端的配置" class="headerlink" title="7、客户端的配置"></a>7、客户端的配置</h1><p>id: 和第四步服务端的id一致<br>path ： 和客户端的id一致，这块和nginx的也是一个，</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2023/05/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><pre><code>之前对IO多路复用，听过，也看了相关博客，但是内化方面的话，实在是不敢恭维自己。今天刚好这个时间，把这块重新梳理下，打一个mark，同时抽象下这块的底层思路。</code></pre><h1 id="二、普及"><a href="#二、普及" class="headerlink" title="二、普及"></a>二、普及</h1><h2 id="1、拉齐认知"><a href="#1、拉齐认知" class="headerlink" title="1、拉齐认知"></a>1、拉齐认知</h2><ul><li>服务端IO，大概分为两个步骤，获取连接，读取数据</li><li>服务端IO，会涉及到用户态和内核态两个，一般IO会从网卡拷贝数据到内核，内核再拷贝数据到用户态</li></ul><h2 id="2、传统IO问题"><a href="#2、传统IO问题" class="headerlink" title="2、传统IO问题"></a>2、传统IO问题</h2><p>  （1）资源利用率低：传统的阻塞IO模型中，每个IO操作都需要一个独立的线程来处理，这会导致大量的线程创建和销毁，消耗系统资源。<br>  （2）并发处理能力差：在高并发场景下，传统的阻塞IO模型难以高效处理大量的并发连接。<br>  （3）线程上下文切换开销大：大量的线程会导致频繁的线程上下文切换，增加系统开销。<br>  （4）可扩展性差：传统的阻塞IO模型在面对大量连接时，性能会急剧下降，难以扩展。</p><h2 id="3、演化节奏"><a href="#3、演化节奏" class="headerlink" title="3、演化节奏"></a>3、演化节奏</h2><ul><li><p>第一步优化：如果用户态上自己写代码，采用一个线程做来网络连接的事，等待读取和处理数据的事交给另一个线程</p><pre><code>问题：只是连接线程没有阻塞，仍然阻塞在了读取上，所以需要系统态提供一个 ”真正的非阻塞的函数“，该函数可以在没有消息时候返回-1</code></pre></li><li><p>第二步优化：用户态上，循环调用系统态的 READ 函数，或者停顿一段时间调用，</p><pre><code>问题：当网络有数据可读取时候，READ函数仍然是阻塞的为每一个连接分配一个线程，很快就会耗光系统资源</code></pre></li><li><p>第三步优化：用户态来了连接，其中一个线程负责放在一个数组内，然后用另一个线程，轮流调用每一个元素的READ函数，</p><pre><code>问题：仍然是用户态需要轮询，且每次调用时候，都需要copy 文件描述符到内核态，检验完再返回用户态。</code></pre></li></ul><h2 id="4、总结问题"><a href="#4、总结问题" class="headerlink" title="4、总结问题"></a>4、总结问题</h2><p>  （1）可否一次性把文件描述符给了系统态，系统自己去监听文件描述符的情况<br>  （2）系统态每次都需要轮询描述符的集合，判断是否有消息可读，耗费资源，高并发场景下，无法处理大量的连接，性能会很差。<br>  （3）系统态返回的仍然是全部的描述符集合，还需要用户态自己去遍历判断哪个连接可读。</p><h1 id="三、IO多路复用"><a href="#三、IO多路复用" class="headerlink" title="三、IO多路复用"></a>三、IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>  （1）起源：Unix中引入，<br>  （2）优化：用户态直接拷贝文件描述符到系统态，<br>  （3）问题：a、select 仍然是阻塞的，b、最大为1024个描述符，c、select是系统态不停的轮询集合 d、需要返回给用户态全部描述符，用户态自己判断</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>  （1）优化：结构体数组来存储文件描述符，连接没有了限制<br>  （2）问题：a、仍然是阻塞的，b、是系统态不停的轮询集合 c、需要返回给用户态全部描述符，用户态自己判断</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>  （1）优化：<br>  a、无需全量拷贝：系统态保存了描述符的集合，用户态只需要告诉增删改，不需要每次都全量拷贝<br>  b、基于事件回调：内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。<br>  c、增量回传信息：内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p><h1 id="四、用户侧如何感知"><a href="#四、用户侧如何感知" class="headerlink" title="四、用户侧如何感知"></a>四、用户侧如何感知</h1><h2 id="1、轮询"><a href="#1、轮询" class="headerlink" title="1、轮询"></a>1、轮询</h2><p>  用户线程可以定期调用epoll_wait，检查是否有事件发生。这种方法简单但效率较低。</p><h2 id="2、信号"><a href="#2、信号" class="headerlink" title="2、信号"></a>2、信号</h2><p>  可以给文件描述符配置信号机制，当epoll有事件发生时，通过信号通知用户线程。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>  用户态完全可以通过线程分割，来实现非阻塞io，但是这并不是多路复用的核心，多路复用的核心，是系统底层提供了一整套批量操作的能力。<br>  那复用了什么东西？<br>  （1）：多个文件描述符共用一个epoll实例<br>  （2）：一个线程处理多个IO操作。<br>  （3）：用户态到系统态的文件描述符集合，只需要一次的拷贝，后续只需要增删改。<br>  （4）：通知机制，多个描述符，都可以服用消息通知机制，只有有了对应的事件，才会通知到用户层。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/"/>
      <url>/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><ul><li>日复盘<ol><li>今天做了哪些事</li><li>遇到哪些问题，我是怎么解决的</li><li>今天的时间是怎么安排的</li><li>今天有哪些启发，学到了什么？</li><li>哪些是应该做的，那些是没必要做的</li></ol></li><li>周复盘<ol><li>这一周有哪些启发，学到了什么</li><li>这一周的时间安排是否合理，是否需要改进</li><li>总结日复盘中遇到的问题，和解决方法。</li></ol></li><li>月复盘<ul><li><ol><li>本月最大的遗憾，</li></ol></li><li><ol start="2"><li>本月最大的收获，</li></ol></li><li><ol start="3"><li>下个月的计划</li></ol></li></ul></li><li>年复盘<ul><li><ol><li>这一年的真实收货</li></ol></li><li><ol start="2"><li>这一年留下的遗憾</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>网站内,要实时高效的处理海量数据<ol><li>用户行为日志</li><li>业务数据库变更</li><li>网站上爬取的数据</li><li>也可以作为系统业务解耦的方式。</li></ol></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>broker：指代kafka的进程，一般放一台服务器上，即真实存储消息的服务器</li><li>topic：逻辑分区，同一类业务数据集合，可以有多个topic</li><li>partition: 物理分区，实际存储每个topic的消息，具体位置是在broker上，每个broker上可能有多个topic的不同分区。</li></ul><h1 id="kafka-的系统设计"><a href="#kafka-的系统设计" class="headerlink" title="kafka 的系统设计"></a>kafka 的系统设计</h1><h2 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h2><p>（1）消息总长度<br>（2）时间戳增量：跟RecordBatch的时间戳的增量差值<br>（3）offset增量：跟RecordBatch的offset的增量差值<br>（4）key长度<br>（5）key<br>（6）value长度<br>（7）value<br>（8）header个数<br>（9）header：自定义的消息元数据，key-value对</p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><p>  (1) .log 文件：每个分区（Partition）对应一个或多个.log文件，这些文件被称为日志段（Log Segment）<br>  (2) .index 文件 每个日志段对应一个.index文件。<br>  (3) .timestamp文件</p><h1 id="kafka-的几大技术"><a href="#kafka-的几大技术" class="headerlink" title="kafka 的几大技术"></a>kafka 的几大技术</h1><h2 id="一、kafka的高可用设计"><a href="#一、kafka的高可用设计" class="headerlink" title="一、kafka的高可用设计"></a>一、kafka的高可用设计</h2><h3 id="1、多副本冗余设置"><a href="#1、多副本冗余设置" class="headerlink" title="1、多副本冗余设置"></a>1、多副本冗余设置</h3><ul><li>即一个partition不仅有leader，还有多个follow分布在不同的机器上，当一个broker宕机后，通过zk的协调，重新选出leader继续提供服务。</li></ul><h3 id="2、ISR列表设置"><a href="#2、ISR列表设置" class="headerlink" title="2、ISR列表设置"></a>2、ISR列表设置</h3><ul><li>in-sync replica，跟leader partition保持同步的follower partition的数量，从新选举的leader只能从该列表出。消息提交成功，也是在该列表中的partition 全部复制成功，才算提交了。</li></ul><h3 id="3、HW和LEO"><a href="#3、HW和LEO" class="headerlink" title="3、HW和LEO"></a>3、HW和LEO</h3><ul><li>HW:代表消费者可看到的消息的offset。</li><li>LEO:代表下一个要写入的数据的offset。<ul><li>过程：<br>（1）leader 收到消息会更新自己的LEO，同时维护每个follow的LEO值<br>（2）follow 拉取消息时候，会带上自己的LEO值，同时能从leader拿到当前leader的HW<br>（3）follow 拉取到leader的HW，更新自己的HW ，策略为 min(leader的HW，自己的LEO)，<br>（4）leader 更新HW，看自己的LEO和follow的LEO，选用min(all LEO) 作为HW。<br>（5）每次leader再重新选举后，都有一个版本概念，以及自己写数据的下标记录。</li></ul></li></ul><h3 id="4、一些参数"><a href="#4、一些参数" class="headerlink" title="4、一些参数"></a>4、一些参数</h3><ul><li>replica.lag.time.max.ms：如果某个follower的LEO一直落后leader超过了该设定的秒，那么才判定这个follower是out-of-sync，</li><li>replica.lag.time.max.ms：规定了follower如果在该时间内仍然没有找leader发送请求，就会认为follower是out-of-sync，就会从ISR列表里移除了</li><li>log.index.interval.bytes：在日志文件写入多少数据，就要在索引文件写一条索引，默认是4KB</li></ul><h2 id="二、kafka的高性能"><a href="#二、kafka的高性能" class="headerlink" title="二、kafka的高性能"></a>二、kafka的高性能</h2><ul><li><p>延迟：是处理一条消息的时间</p></li><li><p>吞吐量：是整个系统处理消息的能力</p><h3 id="1、批处理"><a href="#1、批处理" class="headerlink" title="1、批处理"></a>1、批处理</h3><ul><li>平衡了延迟和吞吐量，让性能更加优秀。</li></ul><h3 id="2、顺序写磁盘"><a href="#2、顺序写磁盘" class="headerlink" title="2、顺序写磁盘"></a>2、顺序写磁盘</h3><ul><li>先写日志缓存（kafka内存）</li><li>达到时间限额，写os 的page  cache</li><li>最后写入磁盘</li></ul><h3 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h3><p>  <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/03_kafka%E9%AB%98%E5%90%9E%E5%90%90%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%88%E9%9D%9E%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%89.jpg" alt="kafka零拷贝优化"></p><h3 id="4、使用了Reactor网络通讯模型"><a href="#4、使用了Reactor网络通讯模型" class="headerlink" title="4、使用了Reactor网络通讯模型"></a>4、使用了Reactor网络通讯模型</h3><ul><li>Acceptor：负责接受新的网络连接。 默认1个</li><li>Processor：负责处理网络I/O操作，包括读取请求和写入响应。默认3</li><li>Request Handler：负责处理具体的请求逻辑。 默认8个</li><li>Selector：Java NIO中的Selector，用于监控多个Channel的I/O事件,每个Processor线程都包含一个Selector，用于监控其负责的网络连接</li></ul></li></ul><h2 id="三、kafka的producer-高性能"><a href="#三、kafka的producer-高性能" class="headerlink" title="三、kafka的producer 高性能"></a>三、kafka的producer 高性能</h2><h3 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h3><ul><li>创建ProducerRecord，包含主题（topic）、分区（partition）、键（key）、值（value），</li><li>根据分区策略选择分区。</li><li>进入缓冲区（RecordAccumulator）中，等待批量发送。batch.size=16k，满了就发出去，linger.ms 表示超过x毫秒也会发出去。</li><li>Sender线程负责从缓冲区中取出消息批次，遍历topic 和 parition，如果发送到同一个broker，进一步整合，最后打包成ProduceRequest。max.request.size=1m，否则就不能发送</li></ul><h3 id="2、核心参数"><a href="#2、核心参数" class="headerlink" title="2、核心参数"></a>2、核心参数</h3><ul><li>cks=0：Producer不等待Broker的确认，消息可能会丢失。</li><li>acks=1：Producer等待Leader确认，消息仅在Leader上持久化后返回确认。</li><li>acks=all（或acks=-1）：Producer等待所有ISR（In-Sync Replicas）中的副本确认，确保消息在多个副本上持久化后返回确认。</li></ul><h3 id="3、防止消息重复提交且保证分区顺序"><a href="#3、防止消息重复提交且保证分区顺序" class="headerlink" title="3、防止消息重复提交且保证分区顺序"></a>3、防止消息重复提交且保证分区顺序</h3><ul><li>enable.idempotence=true：kafka提供的幂等性producer</li><li>原理：每个幂等性Producer实例在初始化时，会从Kafka集群获取一个唯一的Producer ID，每个消息在发送时，会被分配一个递增的序列号。序列号在每个分区内是唯一且递增的，Broker端会维护每个分区的最新序列号，并在接收到消息时进行去重和顺序检查</li></ul><h2 id="四，kafka的consumer-高性能"><a href="#四，kafka的consumer-高性能" class="headerlink" title="四，kafka的consumer 高性能"></a>四，kafka的consumer 高性能</h2><h3 id="1、reblance-时机"><a href="#1、reblance-时机" class="headerlink" title="1、reblance 时机"></a>1、reblance 时机</h3><ul><li>heartbeat.interval.ms：consumer心跳时间，</li><li>session.timeout.ms：kafka多长时间感知不到一个consumer</li><li>max.poll.interval.ms：如果在两次poll操作之间，超过了这个时间，</li></ul><h3 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h3><ul><li>auto.offset.reset：earliest，如果下次重启，发现要消费的offset不在分区的范围内，就会重头开始消费；latest，当没有初始偏移量或当前偏移量超出范围时，消费者将从分区的最新消息开始消费</li><li>enable.auto.commit ： 开启自动提交</li></ul><h2 id="五、broker消息积压了怎么办"><a href="#五、broker消息积压了怎么办" class="headerlink" title="五、broker消息积压了怎么办"></a>五、broker消息积压了怎么办</h2><h3 id="1、首先需要对kafka的topic-进行监控"><a href="#1、首先需要对kafka的topic-进行监控" class="headerlink" title="1、首先需要对kafka的topic 进行监控"></a>1、首先需要对kafka的topic 进行监控</h3><h3 id="2、修改topic-的配置，新增分区"><a href="#2、修改topic-的配置，新增分区" class="headerlink" title="2、修改topic 的配置，新增分区"></a>2、修改topic 的配置，新增分区</h3><h3 id="3、新增消费者实例，加入消费者组"><a href="#3、新增消费者实例，加入消费者组" class="headerlink" title="3、新增消费者实例，加入消费者组"></a>3、新增消费者实例，加入消费者组</h3><h3 id="4、-优化消费者线程"><a href="#4、-优化消费者线程" class="headerlink" title="4、 优化消费者线程"></a>4、 优化消费者线程</h3><h3 id="5、批量拉取消息，增大拉取消息的大小限制。"><a href="#5、批量拉取消息，增大拉取消息的大小限制。" class="headerlink" title="5、批量拉取消息，增大拉取消息的大小限制。"></a>5、批量拉取消息，增大拉取消息的大小限制。</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组</title>
      <link href="/2023/02/02/math/SonArray/"/>
      <url>/2023/02/02/math/SonArray/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数和"><a href="#最大子数和" class="headerlink" title="最大子数和"></a>最大子数和</h1><h2 id="A-暴力求解法——-O-N-2"><a href="#A-暴力求解法——-O-N-2" class="headerlink" title="A. 暴力求解法——$O(N^2)$"></a>A. 暴力求解法——$O(N^2)$</h2><h3 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="1. 题目信息"></a>1. 题目信息</h3><ul><li>输入是一个整数数组，返回是一个整数；</li><li>返回的整数：一个连续子数组的和（一个连续子数组 = 一组连续的下标）；</li><li>如果输入的数组不为空，则返回的整数不为空；</li></ul><h3 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h3><ul><li>使用暴力枚举对所有可能的头部指针i 和尾部指针j，求$sum(nums[i,j])$，记录其中最大的值放入maxSum变量中（i &lt;= j）。</li></ul><h3 id="3-超时优化思路："><a href="#3-超时优化思路：" class="headerlink" title="3. 超时优化思路："></a>3. 超时优化思路：</h3><ul><li><p>nums中每个“极大的”连续的“正负性”相同的连续子数组，要么都在解中，要么都不在解中。</p><p>-1,-2,3,4,5,6,-7 【3,4,5,6为局部极大】</p><p>假设如果[x, x+1]为正负性相同的两个下标，并且x+1在解中，x不在。</p><p>1）nums[x] &gt; 0。如果将x放入解中，解的大小会变大，与解是最大值违背。</p><p>2）nums[x]&lt; 0。nums[x+1]&lt; 0, 解中剔除nums[x+1]，解会变大。</p></li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>数组压缩的思想</li></ul><h2 id="B-贪心法"><a href="#B-贪心法" class="headerlink" title="B 贪心法"></a>B 贪心法</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>对解的区间$[i,j]$的讨论</p><p>1）$nums[i]&gt;0$ 并且$nums[i-1]&lt;0$;</p><p>2）不存在$k\in[i,j]$，使得$sum(nums[i, k])&lt;0$；</p><p>3）不存在$k\in[0,i-1]$，使得$sum(nums[k,i-1])&gt;0$;</p><p>“贪心算法”能够帮助我们找到解的起始下标i：当扫描指针来到解的起始下标时，当前和一定是等于0.</p><h2 id="C-动态规划"><a href="#C-动态规划" class="headerlink" title="C 动态规划"></a>C 动态规划</h2><h3 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>贪心和动态规划</p><ul><li>共同点：</li></ul><p>1）基于子问题求解（无后效性）；</p><p>2）策略驱动。</p><ul><li>不同点：</li></ul><p>1）贪心：局部最优可以得到全局最优；解具备一定的单调性</p><p>2）动态规划：每个子问题可能会记录多种状态不一定只存储最优；对解的单调性要求不高。</p><p>子问题的切割：大部分情况下都是比较自然。</p><h2 id="D-分治法"><a href="#D-分治法" class="headerlink" title="D 分治法"></a>D 分治法</h2><h3 id="1-分治法讲解"><a href="#1-分治法讲解" class="headerlink" title="1 分治法讲解"></a>1 分治法讲解</h3><ul><li><p>问题递归分割：分治法会将原问题分成N个子问题分别进行求解。如果子问题的规模依旧非常大（不能直观的得到答案的规模），那么需要对子问题递归地进行分割。</p><p>+++ 问题的规模/大小实际是指输入的实例（输入到算法中具体的例子）；</p></li><li><p>临界问题求解：可以“简单”求解的问题。一般对临界问题的求解消耗的时间都是$O(1)$。</p></li><li><p>子问题解的合并：当已知子问题的解时，如果通过这些解得到父问题的答案。</p></li></ul><p>算法核心：将大化小，对小问题进行求解，从而求解出原问题。</p><p>算法的难点：如何切割，以及如何将解合并。</p><p>分治法的重要思想：假设当前已经拥有子问题的解。</p><h3 id="2-算法思路-1"><a href="#2-算法思路-1" class="headerlink" title="2 算法思路"></a>2 算法思路</h3><ul><li><p>子问题的解与父问题的解</p><p>（1）父问题S的解在左实例S1中：递归地求解S1</p><p>（2）父问题S的解在右实例S2中：递归地求解S2</p><p>（3）父问题S的解被分在左右两个实例中：</p><p>​        3.1 在S1中，求解是以i作为解的右下标的解区间；</p><p>​        3.2 在S2中，求解是以i+1作为解的坐下标的解区间；</p></li><li><p>如果问题的规模为1，就意味着输入的数组只含有一个整数；</p></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ol><li>暴力求解-&gt;压缩数组-&gt;极大连续同正负性数可以合并（非全负case）-&gt;当序列的第一位是负数的时候，可以抛弃；</li><li>贪心方案-&gt;是要当前和是正数，那么就可以考虑加和下一位，当前的加和序列依旧有潜力成为最大和。</li><li>动态规划：对变种的最大子数和问题的一个思考；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
