<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你好，小兜兜</title>
      <link href="/2024/06/17/%E7%BB%8F%E6%B5%8E/%E5%9C%B0%E6%96%B9%E6%94%BF%E6%B2%BB%E5%92%8C%E7%BB%8F%E6%B5%8E/"/>
      <url>/2024/06/17/%E7%BB%8F%E6%B5%8E/%E5%9C%B0%E6%96%B9%E6%94%BF%E6%B2%BB%E5%92%8C%E7%BB%8F%E6%B5%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="地方政治和经济"><a href="#地方政治和经济" class="headerlink" title="地方政治和经济"></a>地方政治和经济</h1><ul><li>初步测试下</li></ul>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/09/redis/redis%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/03/09/redis/redis%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="redis执行"><a href="#redis执行" class="headerlink" title="redis执行"></a>redis执行</h1><ul><li>执行前的准备</li></ul><blockquote><p>① 判断是否为退出命令，如果是则直接返回；<br>② 非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；<br>③ 获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；<br>④ 用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；<br>⑤ 集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；<br>⑥ 检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；<br>⑦ 持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；<br>⑧ 集群模式最少从节点(slave)验证，如果是集群模式并且配置了 replminslavestowrite(最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；<br>⑨ 只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；<br>⑩ 客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。<br>⑪ 从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；<br>⑫ 服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；<br>⑬ lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；<br>⑭ 事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；<br>⑮ 监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/"/>
      <url>/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><ul><li>日复盘<ol><li>今天做了哪些事</li><li>遇到哪些问题，我是怎么解决的</li><li>今天的时间是怎么安排的</li><li>今天有哪些启发，学到了什么？</li><li>哪些是应该做的，那些是没必要做的</li></ol></li><li>周复盘<ol><li>这一周有哪些启发，学到了什么</li><li>这一周的时间安排是否合理，是否需要改进</li><li>总结日复盘中遇到的问题，和解决方法。</li></ol></li><li>月复盘<ul><li><ol><li>本月最大的遗憾，</li></ol></li><li><ol start="2"><li>本月最大的收获，</li></ol></li><li><ol start="3"><li>下个月的计划</li></ol></li></ul></li><li>年复盘<ul><li><ol><li>这一年的真实收货</li></ol></li><li><ol start="2"><li>这一年留下的遗憾</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组</title>
      <link href="/2023/02/02/math/SonArray/"/>
      <url>/2023/02/02/math/SonArray/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数和"><a href="#最大子数和" class="headerlink" title="最大子数和"></a>最大子数和</h1><h2 id="A-暴力求解法——-O-N-2"><a href="#A-暴力求解法——-O-N-2" class="headerlink" title="A. 暴力求解法——$O(N^2)$"></a>A. 暴力求解法——$O(N^2)$</h2><h3 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="1. 题目信息"></a>1. 题目信息</h3><ul><li>输入是一个整数数组，返回是一个整数；</li><li>返回的整数：一个连续子数组的和（一个连续子数组 = 一组连续的下标）；</li><li>如果输入的数组不为空，则返回的整数不为空；</li></ul><h3 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h3><ul><li>使用暴力枚举对所有可能的头部指针i 和尾部指针j，求$sum(nums[i,j])$，记录其中最大的值放入maxSum变量中（i &lt;= j）。</li></ul><h3 id="3-超时优化思路："><a href="#3-超时优化思路：" class="headerlink" title="3. 超时优化思路："></a>3. 超时优化思路：</h3><ul><li><p>nums中每个“极大的”连续的“正负性”相同的连续子数组，要么都在解中，要么都不在解中。</p><p>-1,-2,3,4,5,6,-7 【3,4,5,6为局部极大】</p><p>假设如果[x, x+1]为正负性相同的两个下标，并且x+1在解中，x不在。</p><p>1）nums[x] &gt; 0。如果将x放入解中，解的大小会变大，与解是最大值违背。</p><p>2）nums[x]&lt; 0。nums[x+1]&lt; 0, 解中剔除nums[x+1]，解会变大。</p></li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>数组压缩的思想</li></ul><h2 id="B-贪心法"><a href="#B-贪心法" class="headerlink" title="B 贪心法"></a>B 贪心法</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>对解的区间$[i,j]$的讨论</p><p>1）$nums[i]&gt;0$ 并且$nums[i-1]&lt;0$;</p><p>2）不存在$k\in[i,j]$，使得$sum(nums[i, k])&lt;0$；</p><p>3）不存在$k\in[0,i-1]$，使得$sum(nums[k,i-1])&gt;0$;</p><p>“贪心算法”能够帮助我们找到解的起始下标i：当扫描指针来到解的起始下标时，当前和一定是等于0.</p><h2 id="C-动态规划"><a href="#C-动态规划" class="headerlink" title="C 动态规划"></a>C 动态规划</h2><h3 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>贪心和动态规划</p><ul><li>共同点：</li></ul><p>1）基于子问题求解（无后效性）；</p><p>2）策略驱动。</p><ul><li>不同点：</li></ul><p>1）贪心：局部最优可以得到全局最优；解具备一定的单调性</p><p>2）动态规划：每个子问题可能会记录多种状态不一定只存储最优；对解的单调性要求不高。</p><p>子问题的切割：大部分情况下都是比较自然。</p><h2 id="D-分治法"><a href="#D-分治法" class="headerlink" title="D 分治法"></a>D 分治法</h2><h3 id="1-分治法讲解"><a href="#1-分治法讲解" class="headerlink" title="1 分治法讲解"></a>1 分治法讲解</h3><ul><li><p>问题递归分割：分治法会将原问题分成N个子问题分别进行求解。如果子问题的规模依旧非常大（不能直观的得到答案的规模），那么需要对子问题递归地进行分割。</p><p>+++ 问题的规模/大小实际是指输入的实例（输入到算法中具体的例子）；</p></li><li><p>临界问题求解：可以“简单”求解的问题。一般对临界问题的求解消耗的时间都是$O(1)$。</p></li><li><p>子问题解的合并：当已知子问题的解时，如果通过这些解得到父问题的答案。</p></li></ul><p>算法核心：将大化小，对小问题进行求解，从而求解出原问题。</p><p>算法的难点：如何切割，以及如何将解合并。</p><p>分治法的重要思想：假设当前已经拥有子问题的解。</p><h3 id="2-算法思路-1"><a href="#2-算法思路-1" class="headerlink" title="2 算法思路"></a>2 算法思路</h3><ul><li><p>子问题的解与父问题的解</p><p>（1）父问题S的解在左实例S1中：递归地求解S1</p><p>（2）父问题S的解在右实例S2中：递归地求解S2</p><p>（3）父问题S的解被分在左右两个实例中：</p><p>​        3.1 在S1中，求解是以i作为解的右下标的解区间；</p><p>​        3.2 在S2中，求解是以i+1作为解的坐下标的解区间；</p></li><li><p>如果问题的规模为1，就意味着输入的数组只含有一个整数；</p></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ol><li>暴力求解-&gt;压缩数组-&gt;极大连续同正负性数可以合并（非全负case）-&gt;当序列的第一位是负数的时候，可以抛弃；</li><li>贪心方案-&gt;是要当前和是正数，那么就可以考虑加和下一位，当前的加和序列依旧有潜力成为最大和。</li><li>动态规划：对变种的最大子数和问题的一个思考；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，小兜兜</title>
      <link href="/2022/01/01/hello-world/"/>
      <url>/2022/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="原来是你"><a href="#原来是你" class="headerlink" title="原来是你"></a>原来是你</h3><p>你好，小兜兜，你是最靓的仔！爸爸爱你。</p><span id="more"></span><p>天天都在玩耍，天天都在拉稀，改变了我的生活，改变了我的态度，改变了我的情绪，你就是我的小天使。</p><h3 id="刚生下的样子"><a href="#刚生下的样子" class="headerlink" title="刚生下的样子"></a>刚生下的样子</h3><p>迄今为止最可爱的仔（beautiful boy）<br><img src="/image/oneMonth.png" alt="那时候的你"></p><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/yank-note-picgo-img-20230226105131.png" alt="就是测试下"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="现在的可爱样子"><a href="#现在的可爱样子" class="headerlink" title="现在的可爱样子"></a>现在的可爱样子</h3><p>可爱样子如下：<br><img src="/image/now8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兜兜 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
