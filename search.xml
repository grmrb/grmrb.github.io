<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>熵减行动</title>
      <link href="/2024/07/02/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E7%86%B5%E5%87%8F%E8%A1%8C%E5%8A%A8/"/>
      <url>/2024/07/02/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/%E7%86%B5%E5%87%8F%E8%A1%8C%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="起由"><a href="#起由" class="headerlink" title="起由"></a>起由</h1><p>经历了22年的巨变，我的职业生涯突然感觉到了很大的压力，今年（24年）尤其感觉到严重的压力，从去年年底得了一次甲流开始，过敏的不仅仅是我的呼吸道，大脑神经一直到现在也在过敏，持续了半年的时间，这段期间，精神内耗到了极点，做事不专注，每天很累，但是仍然收货很小。从而促使我拿起以前看的书《从内耗到心流：复杂时代下的熵减行动指南》，从新走上熵减道路。</p><h1 id="什么是精神内耗"><a href="#什么是精神内耗" class="headerlink" title="什么是精神内耗"></a>什么是精神内耗</h1><pre><code>● 完美主义和强迫倾向：对自己期待过高，总纠缠于细节，要么过度行动，要么迟迟不行动。● 总将焦点放在不可控的结果上：纠结于过去和未来，一直逃避现实，这是内卷群体的通病。● 高敏感、低自尊：过度在意他人言行，总觉得与自己有关，陷入猜疑却又不敢去当面确认。● 高压力、低欲望：找不到压力源，无法说清自己的感受，过度思虑，刻意压抑正常的需求。</code></pre><h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><h2 id="什么是熵增"><a href="#什么是熵增" class="headerlink" title="什么是熵增"></a>什么是熵增</h2><ul><li>这个世界在不停的加加加，各类东西层出不穷，各种思想的教导和社会的反向例子让人迷茫甚至混乱，我们每天被各种噪音包围，跟精神患者一样接受着这个世界的各种信息的刺激，</li><li>导致一个人，一会做这，一会干那，情绪时高时低，躺着无法安心入睡，站着无法注意力集中，总之，精神世界都极度散乱。躺平以及优越的生活环境也无法躲过这个散乱的空虚感，</li><li>最后成了”三十岁死了，八十岁掩埋的人“</li></ul><h2 id="人为什么要努力"><a href="#人为什么要努力" class="headerlink" title="人为什么要努力"></a>人为什么要努力</h2><p>   生命活动就是努力的过程，也是对抗熵增的过程，它是纯利己的，和社会期许及个人道德无关.<br>   万物都是开始从有序到无序，我们的生命都是抵制在生活中产生的正熵，让他在一个稳定的水平上。</p><h2 id="熵减逻辑"><a href="#熵减逻辑" class="headerlink" title="熵减逻辑"></a>熵减逻辑</h2><ul><li>认知熵减<br> 这个世界，总会变成无序或者封闭半死的状态，为了让一切变成高效，且我们每个人生活幸福感提高，那就让我们的生活有序，让思想有序，吸收有效的能量，对外开放，主动排除高熵的垃圾，让我们的生活和思想从回有序状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新开始</title>
      <link href="/2024/06/17/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/today_start/"/>
      <url>/2024/06/17/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/today_start/</url>
      
        <content type="html"><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><ul><li>现在遇到了瓶颈，什么东西都懂一些，但是是否能表达的前后连贯，让人看的饱满，仍需要多练习。</li></ul><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2><div class="markmap-container" style="height:undefined">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;大主题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;背景原因&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;发展经过&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;论证方法&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;作者观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;相似观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;总结范式&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;收集case&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;收集名句&quot;}]}"></svg></div><h2 id="观点评论"><a href="#观点评论" class="headerlink" title="观点评论"></a>观点评论</h2><ul><li>聚沙成塔 集腋成裘 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构下的延时消息</title>
      <link href="/2023/11/11/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E6%96%B9%E6%A1%88/"/>
      <url>/2023/11/11/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一、分布式架构下的延时业务"><a href="#一、分布式架构下的延时业务" class="headerlink" title="一、分布式架构下的延时业务"></a>一、分布式架构下的延时业务</h1><p>电商业务中，有下单后xmin时间无操作提醒，ymin后关单等。<br>违规业务中，有罚单xmin时间后无申诉判决，yday无人处理关单等。</p><p>总之：所有的业务中，抽离一个线上核心单元体后，该单元体承载多个业务操作下的不同状态变更，就有可能涉及到使用延时消息。<br><font color=#FF0000 ><big><strong>任意时刻的延时队列，如何接入！</strong></big></font></p><h1 id="二、猜想-业界方案"><a href="#二、猜想-业界方案" class="headerlink" title="二、猜想+业界方案"></a>二、猜想+业界方案</h1><p>分布式架构下，消息中间件一般都会选择kafka 和 rocketmq，(为什么不选rabbit mq ，都说看不懂源码的缘故，掌控感不强)，</p><h2 id="1、kafka"><a href="#1、kafka" class="headerlink" title="1、kafka"></a>1、kafka</h2><p>不直接支持延时消息。那如何实现变种的延时消息？</p><p><font color=#FF0000 ><big><strong>未尝试，但是问题应该不少，比如方案二的额外服务的稳定性，消息重新投递失败的情况等，只是理论可行</strong></big></font><br>基本思路：消息保存到指定的位置，等到了时间才投入到正式的队列中。</p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方案一</td><td>发送消息中，带消费者实际消费的时间，超过该时间，才进行消费,否则消费到后继续投递到该队列中</td><td>不需要引进额外的存储和队列</td><td>生产端和消费端都需处理延时逻辑</td></tr><tr><td>方案二</td><td>kafka中指定延时队列，生产者直接投递到延时队列中，消息体中包含实际队列</td><td>见名之意，传入到延时队列中，消费者不需要任何其他逻辑</td><td>需要引进额外的队列,还需要引入专门消费延时队列的消费者</td></tr></tbody></table><p>  <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240712-164522@2x.png" alt="流程图"> </p><h2 id="2、ROCKETMQ"><a href="#2、ROCKETMQ" class="headerlink" title="2、ROCKETMQ"></a>2、ROCKETMQ</h2><p>延时的等级，分为messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h<br>缺点：只能支持固定时间的延迟。原因：底层实现是基于每个时间段的topic</p><p>详细原理参考：(<a href="https://blog.csdn.net/Weixiaohuai/article/details/123658301">https://blog.csdn.net/Weixiaohuai/article/details/123658301</a>)</p><h2 id="3、QMQ"><a href="#3、QMQ" class="headerlink" title="3、QMQ"></a>3、QMQ</h2><p>之前有幸使用过去哪儿公司的QMQ消息中间件，(<a href="https://github.com/xxxlxy2008/qmq/blob/master/docs/cn/arch.md">https://github.com/xxxlxy2008/qmq/blob/master/docs/cn/arch.md</a>)</p><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/arch4.png" alt="延时消息存储结构"><br>在延时/定时消息里也存在三种log:</p><p>message log 和实时消息里的message log类似，收到消息后append到该log就返回给producer<br>schedule log 按照投递时间组织，每个小时一个。该log是回放message log后根据延时时间放置对应的log上，这是上面描述的两层hash wheel的第一层，位于磁盘上。schedule log里是包含完整的消息内容的，因为消息内容从message log同步到了schedule log，所以历史message log都可以删除。另外，schedule log是按照延时时间组织的，所以延时时间已过的schedule log文件也可以删除<br>dispatch log 延时/定时消息投递后写入，主要用于在应用重启后能够确定哪些消息已经投递，dispatch log里写入的是消息的offset，不包含消息内容</p><p>qmq中消息的存储方式：</p><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/arch3.png" alt="存储信息结构"><br>上图中方框上方的数字，表示该方框在自己log中的偏移，而方框内的数字是该项的内容。<br>比如message log方框上方的数字:3,6,9几表示这几条消息在message log中的偏移。<br>而consume log中方框内的数字3,6,9,20正对应着message log的偏移，表示这几个位置上的消息都是subject1的消息，consume log方框上方的1,2,3,4表示这几个方框在consume log中的逻辑偏移。<br>pull log方框内的内容对应着consume log的逻辑偏移，而pull log方框外的数字表示pull log的逻辑偏移。</p><p>在实时Server存储模型中有三种重要的log:<br>message log 所有subject的消息进入该log，消息的主存储<br>consume log consume log存储的是message log的索引信息<br>pull log 每个consumer拉取消息的时候会产生pull log，pull log记录的是拉取的消息在consume log中的sequence</p><h2 id="4、redission"><a href="#4、redission" class="headerlink" title="4、redission"></a>4、redission</h2><p>使用redisson的DelayedQueue 可以实现延时队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class DelayQueueService &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(DelayQueueService.class);</span><br><span class="line"></span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String appId;</span><br><span class="line"></span><br><span class="line">    public void setRedissonClient(RedissonClient redissonClient) &#123;</span><br><span class="line">        this.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送延时消息到队列</span><br><span class="line">     *</span><br><span class="line">     * @param t        消息载体</span><br><span class="line">     * @param delay    延迟时间</span><br><span class="line">     * @param timeUnit 时间单位</span><br><span class="line">     * @param callBack 消息处理回调类</span><br><span class="line">     * @param &lt;T&gt;      泛型</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; void send(T t, long delay, TimeUnit timeUnit, Class&lt;? extends AbstractDelayMessageListener&lt;T&gt;&gt; callBack) &#123;</span><br><span class="line">        Objects.requireNonNull(callBack, &quot;the callback object must not be null&quot;);</span><br><span class="line">        String listenerName = callBack.getName();</span><br><span class="line">        send(t, delay, timeUnit, listenerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void send(T t, long delay, TimeUnit timeUnit, String callBackName) &#123;</span><br><span class="line">        Objects.requireNonNull(timeUnit, &quot;the time unit must not be null&quot;);</span><br><span class="line">        Objects.requireNonNull(callBackName, &quot;the callback name must not be null&quot;);</span><br><span class="line">        String queueName = appId + Constant.COLON_SEPARATOR + callBackName;</span><br><span class="line">        log.info(&quot;send message to [&#123;&#125;],delay=[&#123;&#125;],timeUnit=[&#123;&#125;]&quot;, queueName, delay, timeUnit);</span><br><span class="line">        RBlockingQueue&lt;T&gt; blockingFairQueue = redissonClient.getBlockingQueue(queueName);</span><br><span class="line">        RDelayedQueue&lt;T&gt; delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);</span><br><span class="line">        delayedQueue.offer(t, delay, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public class ListenerService implements ApplicationListener&lt;ApplicationStartedEvent&gt; &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(ListenerService.class);</span><br><span class="line">    private static final Map&lt;String, ExecutorService&gt; EXECUTOR_SERVICE_MAP = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程池中线程个数</span><br><span class="line">     */</span><br><span class="line">    private static final int THREADS_CNT = 3;</span><br><span class="line"></span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String appId;</span><br><span class="line"></span><br><span class="line">    public void setRedissonClient(RedissonClient redissonClient) &#123;</span><br><span class="line">        this.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 启动线程监听队列</span><br><span class="line">     *</span><br><span class="line">     * @param queueName 队列名（同监听线程名）</span><br><span class="line">     * @param listener  任务回调监听</span><br><span class="line">     * @param &lt;T&gt;       泛型</span><br><span class="line">     */</span><br><span class="line">    private &lt;T&gt; void initialize(String queueName, AbstractDelayMessageListener listener) &#123;</span><br><span class="line">        log.info(&quot;initialize listener thread start...&quot;);</span><br><span class="line">        RBlockingQueue&lt;T&gt; blockingFairQueue = redissonClient.getBlockingQueue(queueName);</span><br><span class="line">        ExecutorService executorService = EXECUTOR_SERVICE_MAP.get(queueName);</span><br><span class="line">        for (int i = 0; i &lt; THREADS_CNT; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                boolean isShutdown = false;</span><br><span class="line">                while (!isShutdown) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        T t = blockingFairQueue.take();</span><br><span class="line">                        listener.invoke(t);</span><br><span class="line">                    &#125; catch (RedissonShutdownException e) &#123;</span><br><span class="line">                        isShutdown = true;</span><br><span class="line">                        String name = Thread.currentThread().getName();</span><br><span class="line">                        log.info(&quot;redisson listener thread [&#123;&#125;] is closing&quot;, name);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        log.error(&quot;listener thread occurs error&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;initialize listener thread end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static ExecutorService createExecutorService(String simpleListenerName) &#123;</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(&quot;pool-&quot; + simpleListenerName + &quot;-%d&quot;).build();</span><br><span class="line">        return Executors.newFixedThreadPool(THREADS_CNT, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationStartedEvent event) &#123;</span><br><span class="line">        ApplicationContext context = event.getApplicationContext();</span><br><span class="line">        Map&lt;String, AbstractDelayMessageListener&gt; map = context.getBeansOfType(AbstractDelayMessageListener.class);</span><br><span class="line">        for (Map.Entry&lt;String, AbstractDelayMessageListener&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            AbstractDelayMessageListener listener = entry.getValue();</span><br><span class="line"></span><br><span class="line">            String listenerName = listener.getClass().getName();</span><br><span class="line">            //考虑到listenerName过长，不适合用作线程名</span><br><span class="line">            String simpleListenerName = listener.getClass().getSimpleName();</span><br><span class="line">            //队列名字不能重复，此处必须使用listenerName（全路径），不能使用simpleListenerName</span><br><span class="line">            String queueName = appId + Constant.COLON_SEPARATOR + listenerName;</span><br><span class="line">            //存储创建的线程池，key为队列名，value为对应的线程池</span><br><span class="line">            EXECUTOR_SERVICE_MAP.put(queueName, createExecutorService(simpleListenerName));</span><br><span class="line">            initialize(queueName, listener);</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(new Thread(</span><br><span class="line">                    () -&gt; EXECUTOR_SERVICE_MAP.forEach((k, v) -&gt; &#123;</span><br><span class="line">                        log.info(&quot;shutting down ExecutorService [&#123;&#125;]&quot;, k);</span><br><span class="line">                        v.shutdown();</span><br><span class="line">                    &#125;)</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用姿势</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ListenerA extends AbstractDelayMessageListener&lt;DelayMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doInvoke(DelayMessage s) &#123;</span><br><span class="line">log.info(&quot;ListenerA receive message [&#123;&#125;]&quot;, s);</span><br><span class="line">long id = s.getId();</span><br><span class="line">int delay = s.getDelay();</span><br><span class="line">//do your logic</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo负载均衡实战</title>
      <link href="/2023/10/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="读前思考"><a href="#读前思考" class="headerlink" title="读前思考"></a>读前思考</h1><p>dubbo 服务之间调用时候，如果provider端有一个实例的机器性能很差，（长时间GC，或者磁盘打满等），这时候如何降低所有的consumer 调用该provider的概率？</p><h1 id="一、普及"><a href="#一、普及" class="headerlink" title="一、普及"></a>一、普及</h1><p>dubbo都有哪些负载均衡策略？ <a href="https://cn.dubbo.apache.org/zh-cn/blog/2018/08/10/dubbo%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1/">参考dubbo官网的负载均衡</a></p><p>其中<big><strong>基于权重的负载均衡</strong></big>给了思路，可以调整每个provider的权重。</p><table><thead><tr><th>provider</th><th>weight</th></tr></thead><tbody><tr><td>A</td><td>10</td></tr><tr><td>B</td><td>20</td></tr><tr><td>C</td><td>20</td></tr><tr><td>D</td><td>30</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">|          |                    |                    |                              |</span><br><span class="line">+-----------------------------------------------------------------------------------+</span><br><span class="line">1          10                   30                   50                             80</span><br><span class="line"></span><br><span class="line">|-----A----|---------B----------|----------C---------|---------------D--------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------15</span><br><span class="line"></span><br><span class="line">-------------------------------------------37</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------54</span><br></pre></td></tr></table></figure><p>上面的图中一共有4块区域，长度分别是A，B，C和D的权重。使用random.nextInt(10 + 20 + 20 + 30)，从80个数中随机选择一个。然后再判断该数分布在哪个区域。比如，如果随机到37，37是分布在C区域的，那么就选择 Invoker C。15是在B区域，54是在D区域。 </p><h1 id="二、分析大概步骤"><a href="#二、分析大概步骤" class="headerlink" title="二、分析大概步骤"></a>二、分析大概步骤</h1><p>（1）、如何识别 provider 性能差？<br>（2）、性能差的服务，什么时间节点判定为恢复？<br>（3）、如何<big><strong>动态</strong></big>的给provider 赋值权重？<br>（4）、如何扩展dubbo的负载均衡策略？</p><h1 id="三、详细分析"><a href="#三、详细分析" class="headerlink" title="三、详细分析"></a>三、详细分析</h1><h2 id="1、识别性能差"><a href="#1、识别性能差" class="headerlink" title="1、识别性能差"></a>1、识别性能差</h2><p>a、服务调用超时<br>如果消费者在调用提供者时超过了设定的超时时间，通常会抛出如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.RpcException: Invoke remote method timeout. method: &lt;methodName&gt;, provider: &lt;providerAddress&gt;, cause: Waiting server-side response timeout by &lt;timeout&gt;ms</span><br></pre></td></tr></table></figure><p>b、连接超时<br>如果消费者在尝试连接提供者时超时，可能会抛出如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.RpcException: Failed to invoke the method &lt;methodName&gt; in the service &lt;serviceName&gt;. Tried &lt;number&gt; times of the providers [&lt;providerAddress&gt;] (1/1) from the registry &lt;registryAddress&gt; on the consumer &lt;consumerAddress&gt; using the dubbo version &lt;version&gt;. Last error is: Invoke remote method timeout. method: &lt;methodName&gt;, provider: &lt;providerAddress&gt;, cause: Waiting server-side response timeout by &lt;timeout&gt;ms</span><br></pre></td></tr></table></figure><p>c、注册中心超时<br>如果消费者在从注册中心获取提供者信息时超时，可能会抛出如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.RpcException: Failed to invoke the method &lt;methodName&gt; in the service &lt;serviceName&gt;. No provider available for the service &lt;serviceName&gt; from the registry &lt;registryAddress&gt; on the consumer &lt;consumerAddress&gt; using the dubbo version &lt;version&gt;. Please check if the providers have been started and registered.</span><br></pre></td></tr></table></figure><p>综上：一般在调用provider，provider连接，响应长等错误，统一都会返回<big><strong>RpcException</strong></big> ，<br>所以，记录当前机器，<big><strong>在历史某段时间内的响应正确数和错误数</strong></big> ，是判断性能好与差的最重要标杆。</p><h2 id="2、什么时间段恢复？"><a href="#2、什么时间段恢复？" class="headerlink" title="2、什么时间段恢复？"></a>2、什么时间段恢复？</h2><h3 id="a、业务分析"><a href="#a、业务分析" class="headerlink" title="a、业务分析"></a>a、业务分析</h3><p>随着时间的推移，如果机器真的没有了性能问题，那该provider的表现就是，越靠近当前时间的请求窗口内，<big><strong>错误数占比总请求量 的比例越少</strong></big> </p><h3 id="b、区分时间段恢复"><a href="#b、区分时间段恢复" class="headerlink" title="b、区分时间段恢复"></a>b、区分时间段恢复</h3><p>因为是滑动窗口，所以该滑动窗口是可以复用的，<br>（1）、如果当前指向第二个窗口，且窗口内无请求错误。<br>（2）、则判断前一个窗口，前一个窗口也无请求，则滑动到最后一个窗口，判断错误率。<br>（3）、离当前窗口从右往左算，每个窗口的权重分别为：1  、  4   、 16   、64<br>（4）、计算是否返回当前窗口，需要看当前窗口下的错误数+同时历史窗口的错误数，/  全部历史请求的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|                |                 |                |               |</span><br><span class="line">+-------------------------------------------------------------------+ Sliding Windows</span><br><span class="line">1                15                30               45             60</span><br><span class="line">                        ^</span><br><span class="line">                        |</span><br><span class="line">         ^           current 1 (100)</span><br><span class="line">     weight:4                               ^ </span><br><span class="line">         |                                weight:64             </span><br><span class="line">         |                                  |                ^</span><br><span class="line">         |                                  ------------- weight:16</span><br><span class="line">         |                                                  |</span><br><span class="line">         |--------------------------------------------------- </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、动态赋值权重"><a href="#3、动态赋值权重" class="headerlink" title="3、动态赋值权重"></a>3、动态赋值权重</h2><p>a、dubbo默认的权重是 100，<br>b、如果dubbo在预热过程中，权重也会随着时间推移，不停的增加，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private int calculateWarmupWeight(int uptime, int warmup, int weight) &#123;</span><br><span class="line">    int ww = (int) ( uptime / ((float) warmup / weight));</span><br><span class="line">    return ww &lt; 1 ? 1 : (Math.min(ww, weight));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c、如果当前provider判断为性能差，则权重降为<big><strong>X（需要重点实现的）</strong></big><br>d、最后计算多个provider的权重总值，按照权重的负载均衡思路选择一台服务。</p><h2 id="四、详细代码"><a href="#四、详细代码" class="headerlink" title="四、详细代码"></a>四、详细代码</h2><p>感兴趣可以联系我哦！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于注解的日志记录实战</title>
      <link href="/2023/09/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E6%88%98/"/>
      <url>/2023/09/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E6%97%A5%E5%BF%97%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><pre><code>1、后端的核心链路的日志，如 订单的增删改，优惠券的增删改，活动等的操作，都需要记录日志在数据库表中，方便后续审计核查。2、那这块的日志统一管理起来，采用注解形式来实现呢？</code></pre><h1 id="二、技术分析"><a href="#二、技术分析" class="headerlink" title="二、技术分析"></a>二、技术分析</h1><p>1、AOP：既然确定了注解形式，那肯定离不开aop 切面拦截<br>2、SpEL：基于注解解析日志，使用spring 的表达式框架，动态获取上下文来填充日志。<br>3、java反射：自定义函数的解析与执行</p><h1 id="三、实现分析"><a href="#三、实现分析" class="headerlink" title="三、实现分析"></a>三、实现分析</h1><p>1、AOP 首先获取注解的信息。封装成一个日志模板，该模板可以支持<big>动态数据库获取信息</big>，也可以<big>支持SPEL</big> 表达式获取上下文信息<br>2、采用stack 的数据结构，来判断和解析模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static BraceResult findBraceResult(String content) &#123;</span><br><span class="line">        // 找到第一个&quot;&#123;&quot;</span><br><span class="line">        int leftBraceIndex = content.indexOf(&quot;&#123;&quot;);</span><br><span class="line">        int matchedRightBraceIndex = -1;</span><br><span class="line">        if(leftBraceIndex&lt;0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // stack用于处理第一个&quot;&#123;&quot;右边可能出现的&quot;&#123;&quot;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(&#x27;&#123;&#x27;);</span><br><span class="line">        // 从第一个&quot;&#123;&quot;开始遍历，找到其匹配的&quot;&#125;&quot;的index</span><br><span class="line">        for(int i=leftBraceIndex+1;i&lt;content.length();i++) &#123;</span><br><span class="line">            // 第一个&quot;&#123;&quot;的右边还可能有&quot;&#123;&quot;</span><br><span class="line">            if(content.charAt(i) == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">                stack.push(&#x27;&#123;&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(content.charAt(i) == &#x27;&#125;&#x27;) &#123;</span><br><span class="line">                // 遇到&quot;&#125;&quot;，栈中的&quot;&#123;&quot;就需要弹出一个</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if(stack.isEmpty()) &#123;</span><br><span class="line">                // 当栈空了，说明我们要找的和第一个&quot;&#123;&quot;匹配的&quot;&#125;&quot;就找到了</span><br><span class="line">                matchedRightBraceIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有找到相匹配的&quot;&#125;&quot;</span><br><span class="line">        if(matchedRightBraceIndex == -1) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        String betweenBraceContent = content.substring(leftBraceIndex + 1 ,matchedRightBraceIndex);</span><br><span class="line">        return new BraceResult(leftBraceIndex,matchedRightBraceIndex,betweenBraceContent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3、<details><summary>封装自定义函数，后续基于反射，来执行自定义函数，该处的量亮点在于，可以从json结果集中获取信息，也可以使用spel 获取填充信息</summary></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private IExpression parseExpression(String content) &#123;</span><br><span class="line">       BraceResult braceResult = BraceUtils.findBraceResult(content);</span><br><span class="line">       if (null != braceResult) &#123;</span><br><span class="line">           // 自定义函数</span><br><span class="line">           String classAndFunctionName = content.substring(0, braceResult.getLeftBraceIndex());</span><br><span class="line">String className = classAndFunctionName.substring(0, classAndFunctionName.indexOf(&quot;.&quot;));</span><br><span class="line">String functionName = classAndFunctionName.substring(classAndFunctionName.indexOf(&quot;.&quot;) +1);</span><br><span class="line">           String input = content.substring(braceResult.getLeftBraceIndex() + 1, braceResult.getMatchedRightBraceIndex());</span><br><span class="line">String jsonKey = null;</span><br><span class="line">if(content.length() != braceResult.getMatchedRightBraceIndex() + 1) &#123;</span><br><span class="line">jsonKey = content.substring(braceResult.getMatchedRightBraceIndex() + 2);</span><br><span class="line">&#125;</span><br><span class="line">return new FunctionWithJSONTemplate(className,functionName, new FuncInput(input), jsonKey);</span><br><span class="line">       &#125;</span><br><span class="line">else &#123;</span><br><span class="line">           // SpEl表达式</span><br><span class="line">           return new SpELTemplate(content);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class FunctionWithJSONTemplate implements IExpression &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义类名称</span><br><span class="line"> */</span><br><span class="line">private String className;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 自定义函数名称</span><br><span class="line">    */</span><br><span class="line">   private String functionName;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 自定义函数入参</span><br><span class="line">    */</span><br><span class="line">   private FuncInput input;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * json key</span><br><span class="line"> */</span><br><span class="line">private String jsonKey;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String execute(Object result,ProceedingJoinPoint point,</span><br><span class="line">                         OperateLogExpressionEvaluator expressionEvaluator,</span><br><span class="line">                         IFunctionService iFunctionService) &#123;</span><br><span class="line"></span><br><span class="line">       Object value = null;</span><br><span class="line">       if(input.isSpEl()) &#123;</span><br><span class="line">           //执行SpEL</span><br><span class="line">           value = expressionEvaluator.executeObjectExpression(result,point, input.getInput());</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           value = input.getInput();</span><br><span class="line">       &#125;</span><br><span class="line">String functionResult = iFunctionService.apply(className,functionName,value);</span><br><span class="line">if(JSONObject.isValidObject(functionResult))&#123;</span><br><span class="line">JSONObject jsonObj = JSON.parseObject(functionResult);</span><br><span class="line">return jsonObj.getString(jsonKey);</span><br><span class="line">&#125;</span><br><span class="line">return functionResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><h1 id="四、使用注意事项"><a href="#四、使用注意事项" class="headerlink" title="四、使用注意事项"></a>四、使用注意事项</h1><h2 id="对于RT要求高的场景"><a href="#对于RT要求高的场景" class="headerlink" title="对于RT要求高的场景"></a>对于RT要求高的场景</h2><p>（1）建议不要使用自定义函数，<br>（2）最后的日志处理，改成异步发kafka消息。</p><h2 id="对于想使用自定义函数"><a href="#对于想使用自定义函数" class="headerlink" title="对于想使用自定义函数"></a>对于想使用自定义函数</h2><p>（1）有一类场景，如日志模板为 【订单状态从 xxxa 更改为 xxxb】，<br> 那该类日志的方法必须是在事务内，否则方法执行完，就是提交状态，自定义函数获取的是事务提交后的信息</p><h1 id="五、详细实现"><a href="#五、详细实现" class="headerlink" title="五、详细实现"></a>五、详细实现</h1><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><details><summary>(1)解析操作日志模板和表达式，封装成日志模板</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private LogTemplateResult parseOperateLog(Object result,ProceedingJoinPoint point, OperateLog operateLog) &#123;</span><br><span class="line"></span><br><span class="line">      String operator = null;</span><br><span class="line">      String bizNo = null;</span><br><span class="line">String bizType = operateLog.bizType();</span><br><span class="line"></span><br><span class="line">      // 解析业务编码</span><br><span class="line">      bizNo = expressionEvaluator.executeStringExpression(result,point, operateLog.bizNo());</span><br><span class="line">      if (StringUtils.isEmpty(bizNo)) &#123;</span><br><span class="line">LOGGER.warn(&quot;bizNo is empty, please check your bizNo expression&quot;);</span><br><span class="line">         throw new UnsupportedOperationException(&quot;bizNo cannot be empty!!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 解析日志模板和表达式</span><br><span class="line">      LogTemplateResult logTemplateResult = parseLogTemplateResult(operateLog.content());</span><br><span class="line">      // 解析操作人</span><br><span class="line">      operator = expressionEvaluator.executeStringExpression(result,point, operateLog.operator());</span><br><span class="line"></span><br><span class="line">      logTemplateResult.setOperateLog(operateLog);</span><br><span class="line">      logTemplateResult.setBizNo(bizNo);</span><br><span class="line">      logTemplateResult.setOperator(operator);</span><br><span class="line">logTemplateResult.setBizType(bizType);</span><br><span class="line">      logTemplateResult.setPoint(point);</span><br><span class="line"></span><br><span class="line">      return logTemplateResult;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></details>  <details><summary>(2)执行表达式并填充日志模板占位符</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private OperateLogInstance executeExpressionAndFillPlaceholder(Object result,LogTemplateResult logTemplateResult) &#123;</span><br><span class="line">      String logContent = null;</span><br><span class="line">      ProceedingJoinPoint point = logTemplateResult.getPoint();</span><br><span class="line">      OperateLog operateLog = logTemplateResult.getOperateLog();</span><br><span class="line"></span><br><span class="line">      // 如果日志LogContentTemplate里面包含表达式的话</span><br><span class="line">      if (logTemplateResult.isHasExpression()) &#123;</span><br><span class="line">          String logContentTemplate = logTemplateResult.getContentTemplate();</span><br><span class="line">          List&lt;String&gt; expressionResult = new ArrayList&lt;&gt;();</span><br><span class="line">          // 执行自定义函数</span><br><span class="line">          for (IExpression expression : logTemplateResult.getExpressions()) &#123;</span><br><span class="line">              // 保存执行的结果</span><br><span class="line">              expressionResult.add(expression.execute(result,point, expressionEvaluator, iFunctionService));</span><br><span class="line">          &#125;</span><br><span class="line">          // 构造最终的日志content</span><br><span class="line">          logContent = String.format(logContentTemplate, expressionResult.toArray(new String[expressionResult.size()]));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // 普通logContent</span><br><span class="line">          logContent = operateLog.content();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 构造操作日志实例</span><br><span class="line">      return OperateLogInstance.builder()</span><br><span class="line">              .bizNo(logTemplateResult.getBizNo())</span><br><span class="line">              .operator(logTemplateResult.getOperator())</span><br><span class="line">    .bizType(logTemplateResult.getBizType())</span><br><span class="line">              .logContent(logContent)</span><br><span class="line">              .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </details>  <details><summary>(3)存储操作日志，需要业务方自行定义</summary>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface OperateLogStoreService &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 存储操作日志</span><br><span class="line">   */</span><br><span class="line">  void storeOperateLog(OperateLogInstance instance) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </details><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/IParseFunction.png" alt="涉及到的类"></p><h2 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h2><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240710-150453@2x.png" alt="时序图1"><br><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240710-150507@2x.png" alt="时序图2"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程实战与总结</title>
      <link href="/2023/08/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="读前思考"><a href="#读前思考" class="headerlink" title="读前思考"></a>读前思考</h1><p>不使用CompletableFuture，如何使用Future 来优雅实现异步超时处理，错误处理，以及异步任务的依赖？</p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><h2 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h2><pre><code>cpu负责调度系统执行任务，cpu的效率极高，如果一个cpu对应一个进程的一个线程来执行任务的话，那CPU的效率会大大降低。</code></pre><h2 id="底层依靠什么运转"><a href="#底层依靠什么运转" class="headerlink" title="底层依靠什么运转"></a>底层依靠什么运转</h2><ul><li>时间片轮转：<blockquote><p>操作系统将CPU时间划分为多个时间片，每个时间片分配给不同的线程。当一个线程的时间片用完时，操作系统会暂停该线程的执行，并将CPU分配给下一个线程。</p></blockquote></li><li>上下文切换：<blockquote><p>当操作系统暂停一个线程并切换到另一个线程时，需要保存当前线程的上下文（如寄存器状态、程序计数器等），并恢复下一个线程的上下文。<br>  上下文切换会带来一定的开销，但它使得单核CPU能够在多个线程之间快速切换，从而模拟并发执行。</p></blockquote></li></ul><h1 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h1><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>简单易用，直接使用Thread类的方法</td><td>不支持多继承，不利于资源共享</td></tr><tr><td>实现Runnable接口</td><td>支持多继承，利于资源共享</td><td>需要额外创建Thread对象，稍微复杂</td></tr><tr><td>使用Callable和Future</td><td>可以返回结果和抛出异常，适用于需要获取结果的场景</td><td>需要使用ExecutorService和Future，代码稍微复杂</td></tr><tr><td>使用线程池</td><td>高效管理线程，灵活性高，便于资源管理</td><td>复杂性增加，可能导致资源耗尽</td></tr></tbody></table><h2 id="future的几个实现"><a href="#future的几个实现" class="headerlink" title="future的几个实现"></a>future的几个实现</h2><table><thead><tr><th>特性</th><th>Future</th><th>FutureTask</th><th>CompletableFuture</th></tr></thead><tbody><tr><td>概念</td><td>接口，用于表示异步计算的结果</td><td>Future接口的一个具体实现</td><td>Future接口的一个具体实现</td></tr><tr><td>功能</td><td>提供了一些方法来检查计算是否完成、等待计算完成并获取结果</td><td>作为一个任务提交给ExecutorService执行，也可以直接在一个线程中执行</td><td>许多方法来进行异步操作、组合多个异步任务</td></tr><tr><td>引入版本</td><td>Java 5</td><td>Java 5</td><td>Java 8</td></tr><tr><td>是否实现Future接口</td><td>是</td><td>是</td><td>是</td></tr><tr><td>是否实现Runnable接口</td><td>否</td><td>是</td><td>否</td></tr><tr><td>是否支持链式调用</td><td>否</td><td>否</td><td>是</td></tr><tr><td>是否支持组合多个任务</td><td>否</td><td>否</td><td>是</td></tr><tr><td>是否支持异步超时处理</td><td>否</td><td>否</td><td>是（1.9开始支持）</td></tr></tbody></table><h2 id="多线程实战"><a href="#多线程实战" class="headerlink" title="多线程实战"></a>多线程实战</h2><ul><li><p>背景：</p><ul><li>业务：C端页面，很多功能模块需要异步获取结果</li><li>技术：公司的skywalking 组件是5.x版本的，对于CompletableFuture 的异步任务，无法追踪到trace。</li></ul></li><li><p>问题分析：</p><ul><li>业务：1、如果多个模块之间有依赖怎么办？如下一个模块依赖于上一个模块的结果才决定出与不出。</li><li>技术：无法追踪TRACE，意味着无法使用CompletableFuture，那技术上如何适应Future 来优雅实现异步超时处理，错误处理，以及异步任务的依赖？</li></ul></li><li><p>思路：</p><ul><li>异步超时处理：<br>起一个定时的任务，该任务的作用是到时间点检查 提交的任务的线程是否还在运行，如果运行，则记录为超时，同时停止任务。<br>伪代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  FutureTask&lt;?&gt; future = new FutureTask&lt;&gt;(callable);</span><br><span class="line">executorService.submit(future);</span><br><span class="line">  Runnable r = () -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">boolean b = !future.isDone() ;</span><br><span class="line">if (b) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">LOGGER.warn(&quot;&#123;&#125;任务超时啦&quot;,xxx);</span><br><span class="line">future.get(0, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">future.isMayStopIfRunning(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">       future.cancel(true);</span><br><span class="line">LOGGER.error(Strings.EMPTY, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">timeoutExecutor.schedule(r, xxxTime,  TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure></li><li>错误处理：<br>定义一个对象，该对象包含执行线程过程中的全部信息，封装该对象的时机为：在get时候的上下文中来封装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> private boolean success;</span><br><span class="line">private boolean timeout;</span><br><span class="line">/**</span><br><span class="line"> * 执行器名称</span><br><span class="line"> */</span><br><span class="line">private String executorName;</span><br><span class="line">/**</span><br><span class="line"> * 失败原因</span><br><span class="line"> */</span><br><span class="line">private String errorMessage;</span><br><span class="line">private Exception ex;</span><br><span class="line">private long cost;</span><br><span class="line">private T obj;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>异步任务的依赖<br>其实开源界有<a href="https://liteflow.cc/">liteflow</a>之类的流程编排框架，这块简化，大概思路就是，传参进来后，把每个模块的处理结果放在一个转盘（对象）内，给该对象起一个监听器，一旦监听到该属性有值，且符合其他模块的出发条件，立即执行其他模块。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@Accessors(chain = true)</span><br><span class="line">public class LombokBean &#123;</span><br><span class="line">    private String field;</span><br><span class="line">    private PropertyChangeSupport support = new PropertyChangeSupport(this);</span><br><span class="line"></span><br><span class="line">    public void addPropertyChangeListener(PropertyChangeListener listener) &#123;</span><br><span class="line">        support.addPropertyChangeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removePropertyChangeListener(PropertyChangeListener listener) &#123;</span><br><span class="line">        support.removePropertyChangeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setField(String field) &#123;</span><br><span class="line">        String oldField = this.field;</span><br><span class="line">        this.field = field;</span><br><span class="line">        support.firePropertyChange(&quot;field&quot;, oldField, field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、AQS实战"><a href="#三、AQS实战" class="headerlink" title="三、AQS实战"></a>三、AQS实战</h1><h2 id="为什么提起"><a href="#为什么提起" class="headerlink" title="为什么提起"></a>为什么提起</h2><pre><code>异步超时获取，异步获取消息，这两块都需要主线程 、线程池的其他线程的并发获取结果。因为涉及两个线程的操作，属于多线程并发范畴，自然想到了使用AQS来管理任务的状态和数据情况</code></pre><details><summary>重新定义的任务管理对象,这里参考的是开源框架[async](https://github.com/dromara/gobrs-async)</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line">package xxxx;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">    public static final int STOP_STAMP = 5;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">        if (callable == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        sync = new Sync(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCancelled() &#123;</span><br><span class="line">        return sync.innerIsCancelled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isDone() &#123;</span><br><span class="line">        return sync.innerIsDone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">        return sync.innerCancel(mayInterruptIfRunning);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程跑的时候，关闭</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public boolean isMayStopIfRunning(boolean mayStopIfRunning) &#123;</span><br><span class="line">        if (sync.runner != null &amp;&amp; Thread.State.RUNNABLE != sync.runner.getState()) &#123;</span><br><span class="line">            return cancel(mayStopIfRunning);</span><br><span class="line">        &#125;</span><br><span class="line">        return sync.innerStop(mayStopIfRunning);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @throws CancellationException &#123;@inheritDoc&#125;</span><br><span class="line"> * 每个任务都有可能抛出异常</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V get() throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">return sync.innerGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @throws CancellationException &#123;@inheritDoc&#125;</span><br><span class="line"> * 最多延迟 xx 获取结果</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V get(long timeout, TimeUnit unit) throws InterruptedException,</span><br><span class="line">            ExecutionException, TimeoutException &#123;</span><br><span class="line">        return sync.innerGet(unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the result of this Future to the given value unless this future</span><br><span class="line">     * has already been set or has been cancelled. This method is invoked</span><br><span class="line">     * internally by the &lt;tt&gt;run&lt;/tt&gt; method upon successful completion of</span><br><span class="line">     * the computation.</span><br><span class="line">     *</span><br><span class="line">     * @param v the value</span><br><span class="line">     */</span><br><span class="line">    protected void set(V v) &#123;</span><br><span class="line">        sync.innerSet(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param t the cause of failure</span><br><span class="line">     */</span><br><span class="line">    protected void setException(Throwable t) &#123;</span><br><span class="line">        sync.innerSetException(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        sync.innerRun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Synchronization control for FutureTask. Note that this must be a</span><br><span class="line">     * non-static inner class in order to invoke the protected &lt;tt&gt;done&lt;/tt&gt;</span><br><span class="line">     * method. For clarity, all inner class support methods are same as</span><br><span class="line">     * outer, prefixed with &quot;inner&quot;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Uses AQS sync state to represent run status</span><br><span class="line">     */</span><br><span class="line">    private final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID = -7828117401763700385L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * State value representing that task is ready to run</span><br><span class="line">         */</span><br><span class="line">        private static final int READY = 0;</span><br><span class="line">        /**</span><br><span class="line">         * State value representing that task is running</span><br><span class="line">         */</span><br><span class="line">        private static final int RUNNING = 1;</span><br><span class="line">        /**</span><br><span class="line">         * State value representing that task ran</span><br><span class="line">         */</span><br><span class="line">        private static final int RAN = 2;</span><br><span class="line">        /**</span><br><span class="line">         * State value representing that task was cancelled</span><br><span class="line">         */</span><br><span class="line">        private static final int CANCELLED = 4;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The underlying callable</span><br><span class="line">         */</span><br><span class="line">        private final Callable&lt;V&gt; callable;</span><br><span class="line">        /**</span><br><span class="line">         * The result to return from get()</span><br><span class="line">         */</span><br><span class="line">        private V result;</span><br><span class="line">        /**</span><br><span class="line">         * The exception to throw from get()</span><br><span class="line">         */</span><br><span class="line">        private Throwable exception;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The thread running task. When nulled after set/cancel, this</span><br><span class="line">         * indicates that the results are accessible. Must be volatile, to</span><br><span class="line">         * ensure visibility upon completion.</span><br><span class="line">         */</span><br><span class="line">        private volatile Thread runner;</span><br><span class="line"></span><br><span class="line">        Sync(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">            this.callable = callable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private boolean ranOrCancelled(int state) &#123;</span><br><span class="line">            return (state &amp; (RAN | CANCELLED)) != 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Implements AQS base acquire to succeed if ran or cancelled</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected int tryAcquireShared(int ignore) &#123;</span><br><span class="line">            return innerIsDone() ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Implements AQS base release to always signal after setting final</span><br><span class="line">         * done status by nulling runner thread.</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryReleaseShared(int ignore) &#123;</span><br><span class="line">            runner = null;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner is cancelled boolean.</span><br><span class="line">         *</span><br><span class="line">         * @return the boolean</span><br><span class="line">         */</span><br><span class="line">        boolean innerIsCancelled() &#123;</span><br><span class="line">            return getState() == CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner is done boolean.</span><br><span class="line">         *</span><br><span class="line">         * @return the boolean</span><br><span class="line">         */</span><br><span class="line">        boolean innerIsDone() &#123;</span><br><span class="line">            return ranOrCancelled(getState()) &amp;&amp; runner == null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner get v.</span><br><span class="line">         *</span><br><span class="line">         * @return the v</span><br><span class="line">         * @throws InterruptedException the interrupted exception</span><br><span class="line">         * @throws ExecutionException   the execution exception</span><br><span class="line">         */</span><br><span class="line">        V innerGet() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">            acquireSharedInterruptibly(0);</span><br><span class="line">            if (getState() == CANCELLED)</span><br><span class="line">                throw new CancellationException();</span><br><span class="line">            if (exception != null)</span><br><span class="line">                throw new ExecutionException(exception);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner get v.</span><br><span class="line">         *</span><br><span class="line">         * @param nanosTimeout the nanos timeout</span><br><span class="line">         * @return the v</span><br><span class="line">         * @throws InterruptedException the interrupted exception</span><br><span class="line">         * @throws ExecutionException   the execution exception</span><br><span class="line">         * @throws TimeoutException     the timeout exception</span><br><span class="line">         */</span><br><span class="line">        V innerGet(long nanosTimeout) throws InterruptedException,</span><br><span class="line">                ExecutionException, TimeoutException &#123;</span><br><span class="line">            if (!tryAcquireSharedNanos(0, nanosTimeout))</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            if (getState() == CANCELLED)</span><br><span class="line">                throw new CancellationException();</span><br><span class="line">            if (exception != null)</span><br><span class="line">                throw new ExecutionException(exception);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner set.</span><br><span class="line">         *</span><br><span class="line">         * @param v the v</span><br><span class="line">         */</span><br><span class="line">        void innerSet(V v) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int s = getState();</span><br><span class="line">                if (s == RAN)</span><br><span class="line">                    return;</span><br><span class="line">                if (s == CANCELLED) &#123;</span><br><span class="line">                    // aggressively release to set runner to null,</span><br><span class="line">                    // in case we are racing with a cancel request</span><br><span class="line">                    // that will try to interrupt runner</span><br><span class="line">                    releaseShared(0);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">                    result = v;</span><br><span class="line">                    releaseShared(0);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置异常</span><br><span class="line">         *</span><br><span class="line">         * @param t the t</span><br><span class="line">         */</span><br><span class="line">        void innerSetException(Throwable t) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int s = getState();</span><br><span class="line">                if (s == RAN)</span><br><span class="line">                    return;</span><br><span class="line">                if (s == CANCELLED) &#123;</span><br><span class="line">                    // aggressively release to set runner to null,</span><br><span class="line">                    // in case we are racing with a cancel request</span><br><span class="line">                    // that will try to interrupt runner</span><br><span class="line">                    releaseShared(0);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (compareAndSetState(s, RAN)) &#123;</span><br><span class="line">                    exception = t;</span><br><span class="line">                    releaseShared(0);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 避免死循环</span><br><span class="line">         *</span><br><span class="line">         * @param mayStopIfRunning the may stop if running</span><br><span class="line">         * @return boolean boolean</span><br><span class="line">         */</span><br><span class="line">        boolean innerStop(boolean mayStopIfRunning) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int s = getState();</span><br><span class="line">                if (ranOrCancelled(s))</span><br><span class="line">                    return false;</span><br><span class="line">                if (compareAndSetState(s, CANCELLED))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mayStopIfRunning) &#123;</span><br><span class="line">                Thread r = runner;</span><br><span class="line">                if (r != null) &#123;</span><br><span class="line">                    r.stop();//这里调用线程stop方法</span><br><span class="line">                    setState(STOP_STAMP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            releaseShared(0);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置关闭</span><br><span class="line">         *</span><br><span class="line">         * @param mayInterruptIfRunning the may interrupt if running</span><br><span class="line">         * @return the boolean</span><br><span class="line">         */</span><br><span class="line">        boolean innerCancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int s = getState();</span><br><span class="line">                if (ranOrCancelled(s))</span><br><span class="line">                    return false;</span><br><span class="line">                if (compareAndSetState(s, CANCELLED))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mayInterruptIfRunning) &#123;</span><br><span class="line">                Thread r = runner;</span><br><span class="line">                if (r != null) &#123;</span><br><span class="line">                    r.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            releaseShared(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Inner run.</span><br><span class="line">         */</span><br><span class="line">        void innerRun() &#123;</span><br><span class="line">            if (!compareAndSetState(READY, RUNNING))</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            runner = Thread.currentThread();</span><br><span class="line">            if (getState() == RUNNING) &#123; // recheck after setting thread</span><br><span class="line">                V result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    result = callable.call();</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                set(result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                releaseShared(0); // cancel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>AQS是一个用于构建锁和同步器的框架</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>AQS的核心思想是使用一个FIFO（先进先出）的等待队列来管理线程的同步状态。AQS通过一个int类型的状态变量（state）来表示同步状态，并提供了原子操作来修改这个状态。</code></pre><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>同步状态（state）：一个int类型的变量，用于表示同步状态。可以通过getState()、setState(int newState)和compareAndSetState(int expect, int update)方法来访问和修改。</li><li>等待队列（Wait Queue）：一个FIFO队列，用于存放等待获取同步状态的线程。每个节点（Node）表示一个线程，节点之间通过prev和next指针连接</li><li>节点（Node）：AQS中的内部类，用于表示等待队列中的每个节点。每个节点包含线程引用、等待状态、前驱节点和后继节点等信息。</li></ul><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li>独占模式（Exclusive Mode）</li><li>共享模式（Shared Mode）</li><li>队列操作：添加队尾，唤醒下个节点</li></ul><h3 id="常见的实现"><a href="#常见的实现" class="headerlink" title="常见的实现"></a>常见的实现</h3><table><thead><tr><th>类名称</th><th>实现原理</th><th>使用场景</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>维护一个state（初始定义），同时包含await方法，该方法尝试获取共享锁，同时进入等待队列，一旦state为0，所有任务一下全部激活。</td><td>每次调用 countDown() 方法时，计数器减一；当计数器减到零时，所有等待的线程都会被唤醒</td></tr><tr><td>Semaphore</td><td>维护一个state（初始定义），同时包含acquire()方法 和release()，acquire对state -1 ，如果成功，则运行任务，失败，则等待，release()对应的+1</td><td>尝试获取一个许可，如果没有可用的许可，则阻塞当前线程，释放一个许可，并唤醒等待的线程</td></tr><tr><td>ReentrantReadWriteLock</td><td>state的低 16 位（0-15 位）表示写锁的重入次数。高 16 位（16-31 位）表示读锁的重入次数。</td><td>读写锁允许多个读线程同时访问共享资源，但在写线程访问时，所有的读线程和其他写线程都被阻塞，<big><strong>特别注意：当一个线程获取读锁，也不允许它继续获取写锁</strong></big></td></tr></tbody></table><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>AQS 开放了 抽离了获取state的方法，释放state的方法，同时封装了接入队列的方法，基于不同的后去和释放逻辑，<br>不同的实现类，封装自身对获取和释放state的逻辑，可以创造出对线程等待顺序不同的并发操作，非常巧妙的抽象模板模式。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学冲浪</title>
      <link href="/2023/07/02/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E4%BA%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%82%A3%E4%BA%9B%E6%98%AF/"/>
      <url>/2023/07/02/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E4%BA%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%82%A3%E4%BA%9B%E6%98%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="万物互联"><a href="#万物互联" class="headerlink" title="万物互联"></a>万物互联</h1><p>当今社会，都地球村了，你要是看不到村头村尾的事，那只能说这个村的精彩，你不配拥有八卦互吹的场面</p><h1 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h1><p>vps专用： <a href="https://bandwagonhost.com/">这里可以买到服务</a><br>域名专用： 腾讯云和阿里云都可以买到域名。</p><h1 id="2、初步联通"><a href="#2、初步联通" class="headerlink" title="2、初步联通"></a>2、初步联通</h1><p>域名的映射 <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-154005@2x.png" alt="先把域名映射到vps的ip上"></p><h1 id="3、登录vps"><a href="#3、登录vps" class="headerlink" title="3、登录vps"></a>3、登录vps</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release &amp;&amp; yum install -y nginx</span><br></pre></td></tr></table></figure><h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><h2 id="安装certbot-获取证书"><a href="#安装certbot-获取证书" class="headerlink" title="安装certbot 获取证书"></a>安装certbot 获取证书</h2><p>先去官网：<a href="https://certbot.eff.org/instructions?ws=nginx&os=centosrhel8">这里跳转官网</a></p><p>点击如下：<img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-154620@2x.png" alt="入口图片"></p><p>如碰到安装snap的问题，请跳转如下链接<a href="https://stackoverflow.com/questions/74960690/try-to-install-snapd-but-giving-conflicting-requests-error">解决snap问题</a></p><details><summary>可参考的安装包和命令</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wget https://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/rpm-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">wget https://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/rpm-libs-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">wget https://dl.rockylinux.org/pub/rocky/8/BaseOS/aarch64/os/Packages/s/selinux-policy-3.14.3-108.el8.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/libsemanage-2.9-9.el8.x86_64.rpm --allowerasing -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/policycoreutils-2.9-19.el8.x86_64.rpm -y</span><br><span class="line"></span><br><span class="line">sudo rpm -i --force rpm-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">sudo rpm -i --force rpm-libs-4.14.3-19.el8.x86_64.rpm</span><br><span class="line">sudo rpm -i --force selinux-policy-3.14.3-108.el8.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/python3-libsemanage-2.9-9.el8.x86_64.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/python3-policycoreutils-2.9-19.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/policycoreutils-python-utils-2.9-19.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/selinux-policy-minimum-3.14.3-108.el8.noarch.rpm -y</span><br><span class="line">sudo yum install http://mirror.centos.org/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.2-1.el8.x86_64.rpm -y</span><br><span class="line"></span><br><span class="line">sudo yum install https://download-ib01.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/s/snapd-selinux-2.57.6-2.el8.noarch.rpm -y</span><br><span class="line"></span><br><span class="line">sudo yum install snapd -y</span><br><span class="line">sudo yum update snapd  -y</span><br></pre></td></tr></table></figure></details><h1 id="4、安装v2ray"><a href="#4、安装v2ray" class="headerlink" title="4、安装v2ray"></a>4、安装v2ray</h1><p>采用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p>采用如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;log&quot;:&#123;&quot;access&quot;:&quot;/var/log/v2ray/access.log&quot;,&quot;error&quot;:&quot;/var/log/v2ray/error.log&quot;,&quot;loglevel&quot;:&quot;warning&quot;&#125;,&quot;inbounds&quot;:[&#123;&quot;port&quot;:xxx,&quot;listen&quot;:&quot;127.0.0.1&quot;,&quot;protocol&quot;:&quot;vmess&quot;,&quot;settings&quot;:&#123;&quot;clients&quot;:[&#123;&quot;id&quot;:&quot;xxx&quot;,&quot;alterId&quot;:xxx&#125;]&#125;,&quot;streamSettings&quot;:&#123;&quot;network&quot;:&quot;ws&quot;,&quot;wsSettings&quot;:&#123;&quot;path&quot;:&quot;/xxx&quot;&#125;&#125;&#125;],&quot;outbounds&quot;:[&#123;&quot;protocol&quot;:&quot;freedom&quot;,&quot;settings&quot;:&#123;&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="5、配置nginx"><a href="#5、配置nginx" class="headerlink" title="5、配置nginx"></a>5、配置nginx</h1><p>检查nginx配置（一般为/etc/nginx/nginx.conf）<br>certbot自动化脚本会额外新增两个server：80和443，而原有的server 80的配置还在。<br>因此需要检查下，确保server只有两个，listen 80的是HTTP，listen 443的是HTTPS，多余的server配置注释掉。</p><p>最后如下图所示配置</p><p><img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A120240703-164433@2x.png" alt="nginx配置"></p><h1 id="6、安装客户端"><a href="#6、安装客户端" class="headerlink" title="6、安装客户端"></a>6、安装客户端</h1><p>不同的系统，选择不同的客户端：<a href="https://www.linuxv2ray.com/client/">客户端安装</a></p><h1 id="7、客户端的配置"><a href="#7、客户端的配置" class="headerlink" title="7、客户端的配置"></a>7、客户端的配置</h1><p>id: 和第四步服务端的id一致<br>path ： 和客户端的id一致，这块和nginx的也是一个，</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2023/05/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><pre><code>之前对IO多路复用，听过，也看了相关博客，但是内化方面的话，实在是不敢恭维自己。今天刚好这个时间，把这块重新梳理下，打一个mark，同时抽象下这块的底层思路。</code></pre><h1 id="二、普及"><a href="#二、普及" class="headerlink" title="二、普及"></a>二、普及</h1><h2 id="1、拉齐认知"><a href="#1、拉齐认知" class="headerlink" title="1、拉齐认知"></a>1、拉齐认知</h2><ul><li>服务端IO，大概分为两个步骤，获取连接，读取数据</li><li>服务端IO，会涉及到用户态和内核态两个，一般IO会从网卡拷贝数据到内核，内核再拷贝数据到用户态</li></ul><h2 id="2、传统IO问题"><a href="#2、传统IO问题" class="headerlink" title="2、传统IO问题"></a>2、传统IO问题</h2><p>  （1）资源利用率低：传统的阻塞IO模型中，每个IO操作都需要一个独立的线程来处理，这会导致大量的线程创建和销毁，消耗系统资源。<br>  （2）并发处理能力差：在高并发场景下，传统的阻塞IO模型难以高效处理大量的并发连接。<br>  （3）线程上下文切换开销大：大量的线程会导致频繁的线程上下文切换，增加系统开销。<br>  （4）可扩展性差：传统的阻塞IO模型在面对大量连接时，性能会急剧下降，难以扩展。</p><h2 id="3、演化节奏"><a href="#3、演化节奏" class="headerlink" title="3、演化节奏"></a>3、演化节奏</h2><ul><li><p>第一步优化：如果用户态上自己写代码，采用一个线程做来网络连接的事，等待读取和处理数据的事交给另一个线程</p><pre><code>问题：只是连接线程没有阻塞，仍然阻塞在了读取上，所以需要系统态提供一个 ”真正的非阻塞的函数“，该函数可以在没有消息时候返回-1</code></pre></li><li><p>第二步优化：用户态上，循环调用系统态的 READ 函数，或者停顿一段时间调用，</p><pre><code>问题：当网络有数据可读取时候，READ函数仍然是阻塞的为每一个连接分配一个线程，很快就会耗光系统资源</code></pre></li><li><p>第三步优化：用户态来了连接，其中一个线程负责放在一个数组内，然后用另一个线程，轮流调用每一个元素的READ函数，</p><pre><code>问题：仍然是用户态需要轮询，且每次调用时候，都需要copy 文件描述符到内核态，检验完再返回用户态。</code></pre></li></ul><h2 id="4、总结问题"><a href="#4、总结问题" class="headerlink" title="4、总结问题"></a>4、总结问题</h2><p>  （1）可否一次性把文件描述符给了系统态，系统自己去监听文件描述符的情况<br>  （2）系统态每次都需要轮询描述符的集合，判断是否有消息可读，耗费资源，高并发场景下，无法处理大量的连接，性能会很差。<br>  （3）系统态返回的仍然是全部的描述符集合，还需要用户态自己去遍历判断哪个连接可读。</p><h1 id="三、IO多路复用"><a href="#三、IO多路复用" class="headerlink" title="三、IO多路复用"></a>三、IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>  （1）起源：Unix中引入，<br>  （2）优化：用户态直接拷贝文件描述符到系统态，<br>  （3）问题：a、select 仍然是阻塞的，b、最大为1024个描述符，c、select是系统态不停的轮询集合 d、需要返回给用户态全部描述符，用户态自己判断</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>  （1）优化：结构体数组来存储文件描述符，连接没有了限制<br>  （2）问题：a、仍然是阻塞的，b、是系统态不停的轮询集合 c、需要返回给用户态全部描述符，用户态自己判断</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>  （1）优化：<br>  a、无需全量拷贝：系统态保存了描述符的集合，用户态只需要告诉增删改，不需要每次都全量拷贝<br>  b、基于事件回调：内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。<br>  c、增量回传信息：内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p><h1 id="四、用户侧如何感知"><a href="#四、用户侧如何感知" class="headerlink" title="四、用户侧如何感知"></a>四、用户侧如何感知</h1><h2 id="1、轮询"><a href="#1、轮询" class="headerlink" title="1、轮询"></a>1、轮询</h2><p>  用户线程可以定期调用epoll_wait，检查是否有事件发生。这种方法简单但效率较低。</p><h2 id="2、信号"><a href="#2、信号" class="headerlink" title="2、信号"></a>2、信号</h2><p>  可以给文件描述符配置信号机制，当epoll有事件发生时，通过信号通知用户线程。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>  用户态完全可以通过线程分割，来实现非阻塞io，但是这并不是多路复用的核心，多路复用的核心，是系统底层提供了一整套批量操作的能力。<br>  那复用了什么东西？<br>  （1）：多个文件描述符共用一个epoll实例<br>  （2）：一个线程处理多个IO操作。<br>  （3）：用户态到系统态的文件描述符集合，只需要一次的拷贝，后续只需要增删改。<br>  （4）：通知机制，多个描述符，都可以服用消息通知机制，只有有了对应的事件，才会通知到用户层。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/"/>
      <url>/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><ul><li>日复盘<ol><li>今天做了哪些事</li><li>遇到哪些问题，我是怎么解决的</li><li>今天的时间是怎么安排的</li><li>今天有哪些启发，学到了什么？</li><li>哪些是应该做的，那些是没必要做的</li></ol></li><li>周复盘<ol><li>这一周有哪些启发，学到了什么</li><li>这一周的时间安排是否合理，是否需要改进</li><li>总结日复盘中遇到的问题，和解决方法。</li></ol></li><li>月复盘<ul><li><ol><li>本月最大的遗憾，</li></ol></li><li><ol start="2"><li>本月最大的收获，</li></ol></li><li><ol start="3"><li>下个月的计划</li></ol></li></ul></li><li>年复盘<ul><li><ol><li>这一年的真实收货</li></ol></li><li><ol start="2"><li>这一年留下的遗憾</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>网站内,要实时高效的处理海量数据<ol><li>用户行为日志</li><li>业务数据库变更</li><li>网站上爬取的数据</li><li>也可以作为系统业务解耦的方式。</li></ol></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>broker：指代kafka的进程，一般放一台服务器上，即真实存储消息的服务器</li><li>topic：逻辑分区，同一类业务数据集合，可以有多个topic</li><li>partition: 物理分区，实际存储每个topic的消息，具体位置是在broker上，每个broker上可能有多个topic的不同分区。</li></ul><h1 id="kafka-的系统设计"><a href="#kafka-的系统设计" class="headerlink" title="kafka 的系统设计"></a>kafka 的系统设计</h1><h2 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h2><p>（1）消息总长度<br>（2）时间戳增量：跟RecordBatch的时间戳的增量差值<br>（3）offset增量：跟RecordBatch的offset的增量差值<br>（4）key长度<br>（5）key<br>（6）value长度<br>（7）value<br>（8）header个数<br>（9）header：自定义的消息元数据，key-value对</p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><p>  (1) .log 文件：每个分区（Partition）对应一个或多个.log文件，这些文件被称为日志段（Log Segment）<br>  (2) .index 文件 每个日志段对应一个.index文件。<br>  (3) .timestamp文件</p><h1 id="kafka-的几大技术"><a href="#kafka-的几大技术" class="headerlink" title="kafka 的几大技术"></a>kafka 的几大技术</h1><h2 id="一、kafka的高可用设计"><a href="#一、kafka的高可用设计" class="headerlink" title="一、kafka的高可用设计"></a>一、kafka的高可用设计</h2><h3 id="1、多副本冗余设置"><a href="#1、多副本冗余设置" class="headerlink" title="1、多副本冗余设置"></a>1、多副本冗余设置</h3><ul><li>即一个partition不仅有leader，还有多个follow分布在不同的机器上，当一个broker宕机后，通过zk的协调，重新选出leader继续提供服务。</li></ul><h3 id="2、ISR列表设置"><a href="#2、ISR列表设置" class="headerlink" title="2、ISR列表设置"></a>2、ISR列表设置</h3><ul><li>in-sync replica，跟leader partition保持同步的follower partition的数量，从新选举的leader只能从该列表出。消息提交成功，也是在该列表中的partition 全部复制成功，才算提交了。</li></ul><h3 id="3、HW和LEO"><a href="#3、HW和LEO" class="headerlink" title="3、HW和LEO"></a>3、HW和LEO</h3><ul><li>HW:代表消费者可看到的消息的offset。</li><li>LEO:代表下一个要写入的数据的offset。<ul><li>过程：<br>（1）leader 收到消息会更新自己的LEO，同时维护每个follow的LEO值<br>（2）follow 拉取消息时候，会带上自己的LEO值，同时能从leader拿到当前leader的HW<br>（3）follow 拉取到leader的HW，更新自己的HW ，策略为 min(leader的HW，自己的LEO)，<br>（4）leader 更新HW，看自己的LEO和follow的LEO，选用min(all LEO) 作为HW。<br>（5）每次leader再重新选举后，都有一个版本概念，以及自己写数据的下标记录。</li></ul></li></ul><h3 id="4、一些参数"><a href="#4、一些参数" class="headerlink" title="4、一些参数"></a>4、一些参数</h3><ul><li>replica.lag.time.max.ms：如果某个follower的LEO一直落后leader超过了该设定的秒，那么才判定这个follower是out-of-sync，</li><li>replica.lag.time.max.ms：规定了follower如果在该时间内仍然没有找leader发送请求，就会认为follower是out-of-sync，就会从ISR列表里移除了</li><li>log.index.interval.bytes：在日志文件写入多少数据，就要在索引文件写一条索引，默认是4KB</li></ul><h2 id="二、kafka的高性能"><a href="#二、kafka的高性能" class="headerlink" title="二、kafka的高性能"></a>二、kafka的高性能</h2><ul><li><p>延迟：是处理一条消息的时间</p></li><li><p>吞吐量：是整个系统处理消息的能力</p><h3 id="1、批处理"><a href="#1、批处理" class="headerlink" title="1、批处理"></a>1、批处理</h3><ul><li>平衡了延迟和吞吐量，让性能更加优秀。</li></ul><h3 id="2、顺序写磁盘"><a href="#2、顺序写磁盘" class="headerlink" title="2、顺序写磁盘"></a>2、顺序写磁盘</h3><ul><li>先写日志缓存（kafka内存）</li><li>达到时间限额，写os 的page  cache</li><li>最后写入磁盘</li></ul><h3 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h3><p>  <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/03_kafka%E9%AB%98%E5%90%9E%E5%90%90%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%88%E9%9D%9E%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%89.jpg" alt="kafka零拷贝优化"></p><h3 id="4、使用了Reactor网络通讯模型"><a href="#4、使用了Reactor网络通讯模型" class="headerlink" title="4、使用了Reactor网络通讯模型"></a>4、使用了Reactor网络通讯模型</h3><ul><li>Acceptor：负责接受新的网络连接。 默认1个</li><li>Processor：负责处理网络I/O操作，包括读取请求和写入响应。默认3</li><li>Request Handler：负责处理具体的请求逻辑。 默认8个</li><li>Selector：Java NIO中的Selector，用于监控多个Channel的I/O事件,每个Processor线程都包含一个Selector，用于监控其负责的网络连接</li></ul></li></ul><h2 id="三、kafka的producer-高性能"><a href="#三、kafka的producer-高性能" class="headerlink" title="三、kafka的producer 高性能"></a>三、kafka的producer 高性能</h2><h3 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h3><ul><li>创建ProducerRecord，包含主题（topic）、分区（partition）、键（key）、值（value），</li><li>根据分区策略选择分区。</li><li>进入缓冲区（RecordAccumulator）中，等待批量发送。batch.size=16k，满了就发出去，linger.ms 表示超过x毫秒也会发出去。</li><li>Sender线程负责从缓冲区中取出消息批次，遍历topic 和 parition，如果发送到同一个broker，进一步整合，最后打包成ProduceRequest。max.request.size=1m，否则就不能发送</li></ul><h3 id="2、核心参数"><a href="#2、核心参数" class="headerlink" title="2、核心参数"></a>2、核心参数</h3><ul><li>cks=0：Producer不等待Broker的确认，消息可能会丢失。</li><li>acks=1：Producer等待Leader确认，消息仅在Leader上持久化后返回确认。</li><li>acks=all（或acks=-1）：Producer等待所有ISR（In-Sync Replicas）中的副本确认，确保消息在多个副本上持久化后返回确认。</li></ul><h3 id="3、防止消息重复提交且保证分区顺序"><a href="#3、防止消息重复提交且保证分区顺序" class="headerlink" title="3、防止消息重复提交且保证分区顺序"></a>3、防止消息重复提交且保证分区顺序</h3><ul><li>enable.idempotence=true：kafka提供的幂等性producer</li><li>原理：每个幂等性Producer实例在初始化时，会从Kafka集群获取一个唯一的Producer ID，每个消息在发送时，会被分配一个递增的序列号。序列号在每个分区内是唯一且递增的，Broker端会维护每个分区的最新序列号，并在接收到消息时进行去重和顺序检查</li></ul><h2 id="四，kafka的consumer-高性能"><a href="#四，kafka的consumer-高性能" class="headerlink" title="四，kafka的consumer 高性能"></a>四，kafka的consumer 高性能</h2><h3 id="1、reblance-时机"><a href="#1、reblance-时机" class="headerlink" title="1、reblance 时机"></a>1、reblance 时机</h3><ul><li>heartbeat.interval.ms：consumer心跳时间，</li><li>session.timeout.ms：kafka多长时间感知不到一个consumer</li><li>max.poll.interval.ms：如果在两次poll操作之间，超过了这个时间，</li></ul><h3 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h3><ul><li>auto.offset.reset：earliest，如果下次重启，发现要消费的offset不在分区的范围内，就会重头开始消费；latest，当没有初始偏移量或当前偏移量超出范围时，消费者将从分区的最新消息开始消费</li><li>enable.auto.commit ： 开启自动提交</li></ul><h2 id="五、broker消息积压了怎么办"><a href="#五、broker消息积压了怎么办" class="headerlink" title="五、broker消息积压了怎么办"></a>五、broker消息积压了怎么办</h2><h3 id="1、首先需要对kafka的topic-进行监控"><a href="#1、首先需要对kafka的topic-进行监控" class="headerlink" title="1、首先需要对kafka的topic 进行监控"></a>1、首先需要对kafka的topic 进行监控</h3><h3 id="2、修改topic-的配置，新增分区"><a href="#2、修改topic-的配置，新增分区" class="headerlink" title="2、修改topic 的配置，新增分区"></a>2、修改topic 的配置，新增分区</h3><h3 id="3、新增消费者实例，加入消费者组"><a href="#3、新增消费者实例，加入消费者组" class="headerlink" title="3、新增消费者实例，加入消费者组"></a>3、新增消费者实例，加入消费者组</h3><h3 id="4、-优化消费者线程"><a href="#4、-优化消费者线程" class="headerlink" title="4、 优化消费者线程"></a>4、 优化消费者线程</h3><h3 id="5、批量拉取消息，增大拉取消息的大小限制。"><a href="#5、批量拉取消息，增大拉取消息的大小限制。" class="headerlink" title="5、批量拉取消息，增大拉取消息的大小限制。"></a>5、批量拉取消息，增大拉取消息的大小限制。</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组</title>
      <link href="/2023/02/02/math/SonArray/"/>
      <url>/2023/02/02/math/SonArray/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数和"><a href="#最大子数和" class="headerlink" title="最大子数和"></a>最大子数和</h1><h2 id="A-暴力求解法——-O-N-2"><a href="#A-暴力求解法——-O-N-2" class="headerlink" title="A. 暴力求解法——$O(N^2)$"></a>A. 暴力求解法——$O(N^2)$</h2><h3 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="1. 题目信息"></a>1. 题目信息</h3><ul><li>输入是一个整数数组，返回是一个整数；</li><li>返回的整数：一个连续子数组的和（一个连续子数组 = 一组连续的下标）；</li><li>如果输入的数组不为空，则返回的整数不为空；</li></ul><h3 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h3><ul><li>使用暴力枚举对所有可能的头部指针i 和尾部指针j，求$sum(nums[i,j])$，记录其中最大的值放入maxSum变量中（i &lt;= j）。</li></ul><h3 id="3-超时优化思路："><a href="#3-超时优化思路：" class="headerlink" title="3. 超时优化思路："></a>3. 超时优化思路：</h3><ul><li><p>nums中每个“极大的”连续的“正负性”相同的连续子数组，要么都在解中，要么都不在解中。</p><p>-1,-2,3,4,5,6,-7 【3,4,5,6为局部极大】</p><p>假设如果[x, x+1]为正负性相同的两个下标，并且x+1在解中，x不在。</p><p>1）nums[x] &gt; 0。如果将x放入解中，解的大小会变大，与解是最大值违背。</p><p>2）nums[x]&lt; 0。nums[x+1]&lt; 0, 解中剔除nums[x+1]，解会变大。</p></li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>数组压缩的思想</li></ul><h2 id="B-贪心法"><a href="#B-贪心法" class="headerlink" title="B 贪心法"></a>B 贪心法</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>对解的区间$[i,j]$的讨论</p><p>1）$nums[i]&gt;0$ 并且$nums[i-1]&lt;0$;</p><p>2）不存在$k\in[i,j]$，使得$sum(nums[i, k])&lt;0$；</p><p>3）不存在$k\in[0,i-1]$，使得$sum(nums[k,i-1])&gt;0$;</p><p>“贪心算法”能够帮助我们找到解的起始下标i：当扫描指针来到解的起始下标时，当前和一定是等于0.</p><h2 id="C-动态规划"><a href="#C-动态规划" class="headerlink" title="C 动态规划"></a>C 动态规划</h2><h3 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>贪心和动态规划</p><ul><li>共同点：</li></ul><p>1）基于子问题求解（无后效性）；</p><p>2）策略驱动。</p><ul><li>不同点：</li></ul><p>1）贪心：局部最优可以得到全局最优；解具备一定的单调性</p><p>2）动态规划：每个子问题可能会记录多种状态不一定只存储最优；对解的单调性要求不高。</p><p>子问题的切割：大部分情况下都是比较自然。</p><h2 id="D-分治法"><a href="#D-分治法" class="headerlink" title="D 分治法"></a>D 分治法</h2><h3 id="1-分治法讲解"><a href="#1-分治法讲解" class="headerlink" title="1 分治法讲解"></a>1 分治法讲解</h3><ul><li><p>问题递归分割：分治法会将原问题分成N个子问题分别进行求解。如果子问题的规模依旧非常大（不能直观的得到答案的规模），那么需要对子问题递归地进行分割。</p><p>+++ 问题的规模/大小实际是指输入的实例（输入到算法中具体的例子）；</p></li><li><p>临界问题求解：可以“简单”求解的问题。一般对临界问题的求解消耗的时间都是$O(1)$。</p></li><li><p>子问题解的合并：当已知子问题的解时，如果通过这些解得到父问题的答案。</p></li></ul><p>算法核心：将大化小，对小问题进行求解，从而求解出原问题。</p><p>算法的难点：如何切割，以及如何将解合并。</p><p>分治法的重要思想：假设当前已经拥有子问题的解。</p><h3 id="2-算法思路-1"><a href="#2-算法思路-1" class="headerlink" title="2 算法思路"></a>2 算法思路</h3><ul><li><p>子问题的解与父问题的解</p><p>（1）父问题S的解在左实例S1中：递归地求解S1</p><p>（2）父问题S的解在右实例S2中：递归地求解S2</p><p>（3）父问题S的解被分在左右两个实例中：</p><p>​        3.1 在S1中，求解是以i作为解的右下标的解区间；</p><p>​        3.2 在S2中，求解是以i+1作为解的坐下标的解区间；</p></li><li><p>如果问题的规模为1，就意味着输入的数组只含有一个整数；</p></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ol><li>暴力求解-&gt;压缩数组-&gt;极大连续同正负性数可以合并（非全负case）-&gt;当序列的第一位是负数的时候，可以抛弃；</li><li>贪心方案-&gt;是要当前和是正数，那么就可以考虑加和下一位，当前的加和序列依旧有潜力成为最大和。</li><li>动态规划：对变种的最大子数和问题的一个思考；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用redisson的坑</title>
      <link href="/2022/07/04/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/redission%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/04/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/redission%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><pre><code>redis是缓存界的扛把子，而redisson又是java 链接redis 的一哥，每个项目基本都会用到redisson。它的功能丰富让人羡慕，但是功能丰富极有可能导致使用姿势不正常，就爆发线上问题，这里说两个踩得雷以及解决方法。</code></pre><h1 id="二、问题、分析和方案"><a href="#二、问题、分析和方案" class="headerlink" title="二、问题、分析和方案"></a>二、问题、分析和方案</h1><h2 id="1、数据结合在高并发情况下的情况：RMap-和RSet-数据不一致问题"><a href="#1、数据结合在高并发情况下的情况：RMap-和RSet-数据不一致问题" class="headerlink" title="1、数据结合在高并发情况下的情况：RMap 和RSet 数据不一致问题"></a>1、数据结合在高并发情况下的情况：RMap 和RSet 数据不一致问题</h2><p>   操作Rmap： 高并发时候，如果两个线程同时获取Rmap的数据，那原始数据进行操作后，最终结果是延迟放回去数据那个线程对应的结果。<br>   原因：每个线程获取到的都是数据最原始的状态，并没有版本控制一说。</p><pre><code>解决方案：使用时候，根据场景评判是否需要加redisson的锁</code></pre><h2 id="2、-反序列化问题"><a href="#2、-反序列化问题" class="headerlink" title="2、 反序列化问题"></a>2、 反序列化问题</h2><p>   操作对象：如果直接给Redis 中存放对象时候，一定要注意，在类有变化时候，如果使用FstCodec进行对象序列化，反序列化回来的对象会报错，<br>   原因：redisson FstCodec 需要判定类模版</p><pre><code>解决方案： 使用jackson序列化， 或者存入对象时候，先转成json格式进行存储</code></pre><h2 id="3、-阻塞队列内存泄露OOM问题"><a href="#3、-阻塞队列内存泄露OOM问题" class="headerlink" title="3、 阻塞队列内存泄露OOM问题"></a>3、 阻塞队列内存泄露OOM问题</h2><p>   操作对象：在 3.12.5 以下版本，使用 Redisson 的阻塞队列进行take操作，假设如果一直获取不到数据，会存在内存泄漏问题；<br>   原因：使用阻塞队列时，由于连接长时间阻塞无数据，会导致当前连接的会一直进行ping探活，会一直新建CommandData，队列中数据CommandData无限增长最终出现内存泄漏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> //因为一直take，就会触发队列拿数据</span><br><span class="line">public class PingConnectionHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line"> public void channelActive(final ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">     RedisConnection connection = RedisConnection.getFrom(ctx.channel());</span><br><span class="line">     connection.getConnectionPromise().onComplete((res, e) -&gt; &#123;</span><br><span class="line">         if (e == null) &#123;</span><br><span class="line">             sendPing(ctx);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     ctx.fireChannelActive();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //启动定时，不停的执行sendping 方法，</span><br><span class="line"> protected void sendPing(final ChannelHandlerContext ctx) &#123;</span><br><span class="line">     final RedisConnection connection = RedisConnection.getFrom(ctx.channel());</span><br><span class="line">     final RFuture&lt;String&gt; future = connection.async(StringCodec.INSTANCE, RedisCommands.PING);</span><br><span class="line">     </span><br><span class="line">     config.getTimer().newTimeout(new TimerTask() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">             CommandData&lt;?, ?&gt; commandData = connection.getCurrentCommand();</span><br><span class="line">             if ((commandData == null || !commandData.isBlockingCommand()) </span><br><span class="line">                     &amp;&amp; (future.cancel(false) || !future.isSuccess())) &#123;</span><br><span class="line">                 ctx.channel().close();</span><br><span class="line">                 log.debug(&quot;channel: &#123;&#125; closed due to PING response timeout set in &#123;&#125; ms&quot;, ctx.channel(), config.getPingConnectionInterval());</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 sendPing(ctx);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, config.getPingConnectionInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为上面会不停的执行，所以到了这块，就会不停的给queue中新增对象</span><br><span class="line"></span><br><span class="line"> public class ChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler </span><br><span class="line"> //写出时候，如果没有数据，则会在queue中新增一个QueueCommandHolder对象</span><br><span class="line"> public class CommandsQueue extends ChannelDuplexHandler &#123;</span><br><span class="line">      @Override</span><br><span class="line">     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">         if (msg instanceof QueueCommand) &#123;</span><br><span class="line">             QueueCommand data = (QueueCommand) msg;</span><br><span class="line">             QueueCommandHolder holder = queue.peek();</span><br><span class="line">             if (holder != null &amp;&amp; holder.getCommand() == data) &#123;</span><br><span class="line">                 super.write(ctx, msg, promise);</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 queue.add(new QueueCommandHolder(data, promise));</span><br><span class="line">                 sendData(ctx.channel());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             super.write(ctx, msg, promise);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3、-RMap存储对象多导致OOM问题"><a href="#3、-RMap存储对象多导致OOM问题" class="headerlink" title="3、 RMap存储对象多导致OOM问题"></a>3、 RMap存储对象多导致OOM问题</h2><p>   操作CacheMap ：如果使用cacheMap，如果放入太多的key，会导致线上OOM。<br>   原因：java服务会启动过多的Task来定时执行检测Key的过期，<br>   如下代码中的：EvictionTask 及根据不同的key 来起一个定时，如果key 多了，对象也会很多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, V&gt; RMapCache&lt;K, V&gt; getMapCache(String name, Codec codec) &#123;</span><br><span class="line">    return new RedissonMapCache&lt;K, V&gt;(codec, evictionScheduler, commandExecutor, name, this, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public RedissonMapCache(EvictionScheduler evictionScheduler, CommandAsyncExecutor commandExecutor,</span><br><span class="line">                        String name, RedissonClient redisson, MapCacheOptions&lt;K, V&gt; options, WriteBehindService writeBehindService) &#123;</span><br><span class="line">    super(commandExecutor, name, redisson, options, writeBehindService);</span><br><span class="line">    if (evictionScheduler != null) &#123;</span><br><span class="line">        evictionScheduler.schedule(getRawName(), getTimeoutSetName(), getIdleSetName(), getExpiredChannelName(), getLastAccessTimeSetName(), options);</span><br><span class="line">    &#125;</span><br><span class="line">    this.evictionScheduler = evictionScheduler;</span><br><span class="line">    this.publishCommand = commandExecutor.getConnectionManager().getSubscribeService().getPublishCommand();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> public void schedule(String name, String timeoutSetName, String maxIdleSetName,</span><br><span class="line">                     String expiredChannelName, String lastAccessTimeSetName, MapCacheOptions&lt;?, ?&gt; options) &#123;</span><br><span class="line">    boolean removeEmpty = false;</span><br><span class="line">    if (options != null) &#123;</span><br><span class="line">        removeEmpty = options.isRemoveEmptyEvictionTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EvictionTask task = new MapCacheEvictionTask(name, timeoutSetName, maxIdleSetName, expiredChannelName, lastAccessTimeSetName,</span><br><span class="line">            executor, removeEmpty, this);</span><br><span class="line">    EvictionTask prevTask = tasks.putIfAbsent(name, task);</span><br><span class="line">    if (prevTask == null) &#123;</span><br><span class="line">        task.schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>解决方案：使用redis 的原始map，同时使用expire 来让原始map过期，至于map中的详细数据，则自维护一个 过期策略，如下给出示例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public class OwnLFU &lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">private final int capacity;</span><br><span class="line"></span><br><span class="line">public OwnLFU(int capacity) &#123;</span><br><span class="line">super(capacity, 0.75f, true);</span><br><span class="line">this.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">//这里也可以加上自己的逻辑,比如，如果往该LFU里面存入的是 时间戳之类的，就对key进行比对，返回是否删除</span><br><span class="line">//if((Long)eldest.getKey() &gt; System.currentTimeMillis())&#123;</span><br><span class="line">//return true;</span><br><span class="line">//&#125;</span><br><span class="line">return  size() &gt; capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
