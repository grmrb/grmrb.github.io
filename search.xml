<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重新开始</title>
      <link href="/2024/06/17/today_start/"/>
      <url>/2024/06/17/today_start/</url>
      
        <content type="html"><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><ul><li>现在遇到了瓶颈，什么东西都懂一些，但是是否能表达的前后连贯，让人看的饱满，仍需要多练习。</li></ul><h2 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h2><div class="markmap-container" style="height:undefined">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;大主题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;背景原因&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;发展经过&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;论证方法&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;作者观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;相似观点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;总结范式&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;收集case&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;收集名句&quot;}]}"></svg></div><h2 id="观点评论"><a href="#观点评论" class="headerlink" title="观点评论"></a>观点评论</h2><ul><li>聚沙成塔 集腋成裘 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/"/>
      <url>/2023/03/08/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><ul><li>日复盘<ol><li>今天做了哪些事</li><li>遇到哪些问题，我是怎么解决的</li><li>今天的时间是怎么安排的</li><li>今天有哪些启发，学到了什么？</li><li>哪些是应该做的，那些是没必要做的</li></ol></li><li>周复盘<ol><li>这一周有哪些启发，学到了什么</li><li>这一周的时间安排是否合理，是否需要改进</li><li>总结日复盘中遇到的问题，和解决方法。</li></ol></li><li>月复盘<ul><li><ol><li>本月最大的遗憾，</li></ol></li><li><ol start="2"><li>本月最大的收获，</li></ol></li><li><ol start="3"><li>下个月的计划</li></ol></li></ul></li><li>年复盘<ul><li><ol><li>这一年的真实收货</li></ol></li><li><ol start="2"><li>这一年留下的遗憾</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/01/java%E6%8A%80%E6%9C%AF%E6%80%BB%E8%AE%A1/kafka%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>网站内,要实时高效的处理海量数据<ol><li>用户行为日志</li><li>业务数据库变更</li><li>网站上爬取的数据</li><li>也可以作为系统业务解耦的方式。</li></ol></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>broker：指代kafka的进程，一般放一台服务器上，即真实存储消息的服务器</li><li>topic：逻辑分区，同一类业务数据集合，可以有多个topic</li><li>partition: 物理分区，实际存储每个topic的消息，具体位置是在broker上，每个broker上可能有多个topic的不同分区。</li></ul><h1 id="kafka-的系统设计"><a href="#kafka-的系统设计" class="headerlink" title="kafka 的系统设计"></a>kafka 的系统设计</h1><h2 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h2><p>（1）消息总长度<br>（2）时间戳增量：跟RecordBatch的时间戳的增量差值<br>（3）offset增量：跟RecordBatch的offset的增量差值<br>（4）key长度<br>（5）key<br>（6）value长度<br>（7）value<br>（8）header个数<br>（9）header：自定义的消息元数据，key-value对</p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><p>  (1) .log 文件：每个分区（Partition）对应一个或多个.log文件，这些文件被称为日志段（Log Segment）<br>  (2) .index 文件 每个日志段对应一个.index文件。<br>  (3) .timestamp文件</p><h1 id="kafka-的几大技术"><a href="#kafka-的几大技术" class="headerlink" title="kafka 的几大技术"></a>kafka 的几大技术</h1><h2 id="一、kafka的高可用设计"><a href="#一、kafka的高可用设计" class="headerlink" title="一、kafka的高可用设计"></a>一、kafka的高可用设计</h2><h3 id="1、多副本冗余设置"><a href="#1、多副本冗余设置" class="headerlink" title="1、多副本冗余设置"></a>1、多副本冗余设置</h3><ul><li>即一个partition不仅有leader，还有多个follow分布在不同的机器上，当一个broker宕机后，通过zk的协调，重新选出leader继续提供服务。</li></ul><h3 id="2、ISR列表设置"><a href="#2、ISR列表设置" class="headerlink" title="2、ISR列表设置"></a>2、ISR列表设置</h3><ul><li>in-sync replica，跟leader partition保持同步的follower partition的数量，从新选举的leader只能从该列表出。消息提交成功，也是在该列表中的partition 全部复制成功，才算提交了。</li></ul><h3 id="3、HW和LEO"><a href="#3、HW和LEO" class="headerlink" title="3、HW和LEO"></a>3、HW和LEO</h3><ul><li>HW:代表消费者可看到的消息的offset。</li><li>LEO:代表下一个要写入的数据的offset。<ul><li>过程：<br>（1）leader 收到消息会更新自己的LEO，同时维护每个follow的LEO值<br>（2）follow 拉取消息时候，会带上自己的LEO值，同时能从leader拿到当前leader的HW<br>（3）follow 拉取到leader的HW，更新自己的HW ，策略为 min(leader的HW，自己的LEO)，<br>（4）leader 更新HW，看自己的LEO和follow的LEO，选用min(all LEO) 作为HW。<br>（5）每次leader再重新选举后，都有一个版本概念，以及自己写数据的下标记录。</li></ul></li></ul><h3 id="4、一些参数"><a href="#4、一些参数" class="headerlink" title="4、一些参数"></a>4、一些参数</h3><ul><li>replica.lag.time.max.ms：如果某个follower的LEO一直落后leader超过了该设定的秒，那么才判定这个follower是out-of-sync，</li><li>replica.lag.time.max.ms：规定了follower如果在该时间内仍然没有找leader发送请求，就会认为follower是out-of-sync，就会从ISR列表里移除了</li><li>log.index.interval.bytes：在日志文件写入多少数据，就要在索引文件写一条索引，默认是4KB</li></ul><h2 id="二、kafka的高性能"><a href="#二、kafka的高性能" class="headerlink" title="二、kafka的高性能"></a>二、kafka的高性能</h2><ul><li><p>延迟：是处理一条消息的时间</p></li><li><p>吞吐量：是整个系统处理消息的能力</p><h3 id="1、批处理"><a href="#1、批处理" class="headerlink" title="1、批处理"></a>1、批处理</h3><ul><li>平衡了延迟和吞吐量，让性能更加优秀。</li></ul><h3 id="2、顺序写磁盘"><a href="#2、顺序写磁盘" class="headerlink" title="2、顺序写磁盘"></a>2、顺序写磁盘</h3><ul><li>先写日志缓存（kafka内存）</li><li>达到时间限额，写os 的page  cache</li><li>最后写入磁盘</li></ul><h3 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h3><p>  <img src="https://raw.githubusercontent.com/grmrb/pictures/master/img/03_kafka%E9%AB%98%E5%90%9E%E5%90%90%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%88%E9%9D%9E%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%89.jpg" alt="kafka零拷贝优化"></p><h3 id="4、使用了Reactor网络通讯模型"><a href="#4、使用了Reactor网络通讯模型" class="headerlink" title="4、使用了Reactor网络通讯模型"></a>4、使用了Reactor网络通讯模型</h3><ul><li>Acceptor：负责接受新的网络连接。 默认1个</li><li>Processor：负责处理网络I/O操作，包括读取请求和写入响应。默认3</li><li>Request Handler：负责处理具体的请求逻辑。 默认8个</li><li>Selector：Java NIO中的Selector，用于监控多个Channel的I/O事件,每个Processor线程都包含一个Selector，用于监控其负责的网络连接</li></ul></li></ul><h2 id="三、kafka的producer-高性能"><a href="#三、kafka的producer-高性能" class="headerlink" title="三、kafka的producer 高性能"></a>三、kafka的producer 高性能</h2><h3 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h3><ul><li>创建ProducerRecord，包含主题（topic）、分区（partition）、键（key）、值（value），</li><li>根据分区策略选择分区。</li><li>进入缓冲区（RecordAccumulator）中，等待批量发送。batch.size=16k，满了就发出去，linger.ms 表示超过x毫秒也会发出去。</li><li>Sender线程负责从缓冲区中取出消息批次，遍历topic 和 parition，如果发送到同一个broker，进一步整合，最后打包成ProduceRequest。max.request.size=1m，否则就不能发送</li></ul><h3 id="2、核心参数"><a href="#2、核心参数" class="headerlink" title="2、核心参数"></a>2、核心参数</h3><ul><li>cks=0：Producer不等待Broker的确认，消息可能会丢失。</li><li>acks=1：Producer等待Leader确认，消息仅在Leader上持久化后返回确认。</li><li>acks=all（或acks=-1）：Producer等待所有ISR（In-Sync Replicas）中的副本确认，确保消息在多个副本上持久化后返回确认。</li></ul><h3 id="3、防止消息重复提交且保证分区顺序"><a href="#3、防止消息重复提交且保证分区顺序" class="headerlink" title="3、防止消息重复提交且保证分区顺序"></a>3、防止消息重复提交且保证分区顺序</h3><ul><li>enable.idempotence=true：kafka提供的幂等性producer</li><li>原理：每个幂等性Producer实例在初始化时，会从Kafka集群获取一个唯一的Producer ID，每个消息在发送时，会被分配一个递增的序列号。序列号在每个分区内是唯一且递增的，Broker端会维护每个分区的最新序列号，并在接收到消息时进行去重和顺序检查</li></ul><h2 id="四，kafka的consumer-高性能"><a href="#四，kafka的consumer-高性能" class="headerlink" title="四，kafka的consumer 高性能"></a>四，kafka的consumer 高性能</h2><h3 id="1、reblance-时机"><a href="#1、reblance-时机" class="headerlink" title="1、reblance 时机"></a>1、reblance 时机</h3><ul><li>heartbeat.interval.ms：consumer心跳时间，</li><li>session.timeout.ms：kafka多长时间感知不到一个consumer</li><li>max.poll.interval.ms：如果在两次poll操作之间，超过了这个时间，</li></ul><h3 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h3><ul><li>auto.offset.reset：earliest，如果下次重启，发现要消费的offset不在分区的范围内，就会重头开始消费；latest，当没有初始偏移量或当前偏移量超出范围时，消费者将从分区的最新消息开始消费</li><li>enable.auto.commit ： 开启自动提交</li></ul><h2 id="五、broker消息积压了怎么办"><a href="#五、broker消息积压了怎么办" class="headerlink" title="五、broker消息积压了怎么办"></a>五、broker消息积压了怎么办</h2><h3 id="1、首先需要对kafka的topic-进行监控"><a href="#1、首先需要对kafka的topic-进行监控" class="headerlink" title="1、首先需要对kafka的topic 进行监控"></a>1、首先需要对kafka的topic 进行监控</h3><h3 id="2、修改topic-的配置，新增分区"><a href="#2、修改topic-的配置，新增分区" class="headerlink" title="2、修改topic 的配置，新增分区"></a>2、修改topic 的配置，新增分区</h3><h3 id="3、新增消费者实例，加入消费者组"><a href="#3、新增消费者实例，加入消费者组" class="headerlink" title="3、新增消费者实例，加入消费者组"></a>3、新增消费者实例，加入消费者组</h3><h3 id="4、-优化消费者线程"><a href="#4、-优化消费者线程" class="headerlink" title="4、 优化消费者线程"></a>4、 优化消费者线程</h3><h3 id="5、批量拉取消息，增大拉取消息的大小限制。"><a href="#5、批量拉取消息，增大拉取消息的大小限制。" class="headerlink" title="5、批量拉取消息，增大拉取消息的大小限制。"></a>5、批量拉取消息，增大拉取消息的大小限制。</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组</title>
      <link href="/2023/02/02/math/SonArray/"/>
      <url>/2023/02/02/math/SonArray/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数和"><a href="#最大子数和" class="headerlink" title="最大子数和"></a>最大子数和</h1><h2 id="A-暴力求解法——-O-N-2"><a href="#A-暴力求解法——-O-N-2" class="headerlink" title="A. 暴力求解法——$O(N^2)$"></a>A. 暴力求解法——$O(N^2)$</h2><h3 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="1. 题目信息"></a>1. 题目信息</h3><ul><li>输入是一个整数数组，返回是一个整数；</li><li>返回的整数：一个连续子数组的和（一个连续子数组 = 一组连续的下标）；</li><li>如果输入的数组不为空，则返回的整数不为空；</li></ul><h3 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h3><ul><li>使用暴力枚举对所有可能的头部指针i 和尾部指针j，求$sum(nums[i,j])$，记录其中最大的值放入maxSum变量中（i &lt;= j）。</li></ul><h3 id="3-超时优化思路："><a href="#3-超时优化思路：" class="headerlink" title="3. 超时优化思路："></a>3. 超时优化思路：</h3><ul><li><p>nums中每个“极大的”连续的“正负性”相同的连续子数组，要么都在解中，要么都不在解中。</p><p>-1,-2,3,4,5,6,-7 【3,4,5,6为局部极大】</p><p>假设如果[x, x+1]为正负性相同的两个下标，并且x+1在解中，x不在。</p><p>1）nums[x] &gt; 0。如果将x放入解中，解的大小会变大，与解是最大值违背。</p><p>2）nums[x]&lt; 0。nums[x+1]&lt; 0, 解中剔除nums[x+1]，解会变大。</p></li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>数组压缩的思想</li></ul><h2 id="B-贪心法"><a href="#B-贪心法" class="headerlink" title="B 贪心法"></a>B 贪心法</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>对解的区间$[i,j]$的讨论</p><p>1）$nums[i]&gt;0$ 并且$nums[i-1]&lt;0$;</p><p>2）不存在$k\in[i,j]$，使得$sum(nums[i, k])&lt;0$；</p><p>3）不存在$k\in[0,i-1]$，使得$sum(nums[k,i-1])&gt;0$;</p><p>“贪心算法”能够帮助我们找到解的起始下标i：当扫描指针来到解的起始下标时，当前和一定是等于0.</p><h2 id="C-动态规划"><a href="#C-动态规划" class="headerlink" title="C 动态规划"></a>C 动态规划</h2><h3 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h3><p>贪心和动态规划</p><ul><li>共同点：</li></ul><p>1）基于子问题求解（无后效性）；</p><p>2）策略驱动。</p><ul><li>不同点：</li></ul><p>1）贪心：局部最优可以得到全局最优；解具备一定的单调性</p><p>2）动态规划：每个子问题可能会记录多种状态不一定只存储最优；对解的单调性要求不高。</p><p>子问题的切割：大部分情况下都是比较自然。</p><h2 id="D-分治法"><a href="#D-分治法" class="headerlink" title="D 分治法"></a>D 分治法</h2><h3 id="1-分治法讲解"><a href="#1-分治法讲解" class="headerlink" title="1 分治法讲解"></a>1 分治法讲解</h3><ul><li><p>问题递归分割：分治法会将原问题分成N个子问题分别进行求解。如果子问题的规模依旧非常大（不能直观的得到答案的规模），那么需要对子问题递归地进行分割。</p><p>+++ 问题的规模/大小实际是指输入的实例（输入到算法中具体的例子）；</p></li><li><p>临界问题求解：可以“简单”求解的问题。一般对临界问题的求解消耗的时间都是$O(1)$。</p></li><li><p>子问题解的合并：当已知子问题的解时，如果通过这些解得到父问题的答案。</p></li></ul><p>算法核心：将大化小，对小问题进行求解，从而求解出原问题。</p><p>算法的难点：如何切割，以及如何将解合并。</p><p>分治法的重要思想：假设当前已经拥有子问题的解。</p><h3 id="2-算法思路-1"><a href="#2-算法思路-1" class="headerlink" title="2 算法思路"></a>2 算法思路</h3><ul><li><p>子问题的解与父问题的解</p><p>（1）父问题S的解在左实例S1中：递归地求解S1</p><p>（2）父问题S的解在右实例S2中：递归地求解S2</p><p>（3）父问题S的解被分在左右两个实例中：</p><p>​        3.1 在S1中，求解是以i作为解的右下标的解区间；</p><p>​        3.2 在S2中，求解是以i+1作为解的坐下标的解区间；</p></li><li><p>如果问题的规模为1，就意味着输入的数组只含有一个整数；</p></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ol><li>暴力求解-&gt;压缩数组-&gt;极大连续同正负性数可以合并（非全负case）-&gt;当序列的第一位是负数的时候，可以抛弃；</li><li>贪心方案-&gt;是要当前和是正数，那么就可以考虑加和下一位，当前的加和序列依旧有潜力成为最大和。</li><li>动态规划：对变种的最大子数和问题的一个思考；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
